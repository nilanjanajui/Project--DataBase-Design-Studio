{"ast":null,"code":"/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { isAstNode, isReference } from '../syntax-tree.js';\nimport { DONE_RESULT, stream, StreamImpl, TreeStreamImpl } from './stream.js';\nimport { inRange } from './cst-utils.js';\n/**\n * Link the `$container` and other related properties of every AST node that is directly contained\n * in the given `node`.\n */\nexport function linkContentToContainer(node) {\n  for (const [name, value] of Object.entries(node)) {\n    if (!name.startsWith('$')) {\n      if (Array.isArray(value)) {\n        value.forEach((item, index) => {\n          if (isAstNode(item)) {\n            item.$container = node;\n            item.$containerProperty = name;\n            item.$containerIndex = index;\n          }\n        });\n      } else if (isAstNode(value)) {\n        value.$container = node;\n        value.$containerProperty = name;\n      }\n    }\n  }\n}\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and return the first\n * node that matches the type predicate. If the start node itself matches, it is returned.\n * If no container matches, `undefined` is returned.\n */\nexport function getContainerOfType(node, typePredicate) {\n  let item = node;\n  while (item) {\n    if (typePredicate(item)) {\n      return item;\n    }\n    item = item.$container;\n  }\n  return undefined;\n}\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and check for existence\n * of a container that matches the given predicate. The start node is included in the checks.\n */\nexport function hasContainerOfType(node, predicate) {\n  let item = node;\n  while (item) {\n    if (predicate(item)) {\n      return true;\n    }\n    item = item.$container;\n  }\n  return false;\n}\n/**\n * Retrieve the document in which the given AST node is contained. A reference to the document is\n * usually held by the root node of the AST.\n *\n * @throws an error if the node is not contained in a document.\n */\nexport function getDocument(node) {\n  const rootNode = findRootNode(node);\n  const result = rootNode.$document;\n  if (!result) {\n    throw new Error('AST node has no document.');\n  }\n  return result;\n}\n/**\n * Returns the root node of the given AST node by following the `$container` references.\n */\nexport function findRootNode(node) {\n  while (node.$container) {\n    node = node.$container;\n  }\n  return node;\n}\n/**\n * Create a stream of all AST nodes that are directly contained in the given node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nexport function streamContents(node, options) {\n  if (!node) {\n    throw new Error('Node must be an AstNode.');\n  }\n  const range = options === null || options === void 0 ? void 0 : options.range;\n  return new StreamImpl(() => ({\n    keys: Object.keys(node),\n    keyIndex: 0,\n    arrayIndex: 0\n  }), state => {\n    while (state.keyIndex < state.keys.length) {\n      const property = state.keys[state.keyIndex];\n      if (!property.startsWith('$')) {\n        const value = node[property];\n        if (isAstNode(value)) {\n          state.keyIndex++;\n          if (isAstNodeInRange(value, range)) {\n            return {\n              done: false,\n              value\n            };\n          }\n        } else if (Array.isArray(value)) {\n          while (state.arrayIndex < value.length) {\n            const index = state.arrayIndex++;\n            const element = value[index];\n            if (isAstNode(element) && isAstNodeInRange(element, range)) {\n              return {\n                done: false,\n                value: element\n              };\n            }\n          }\n          state.arrayIndex = 0;\n        }\n      }\n      state.keyIndex++;\n    }\n    return DONE_RESULT;\n  });\n}\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node.\n * This does not include the root node itself.\n */\nexport function streamAllContents(root, options) {\n  if (!root) {\n    throw new Error('Root node must be an AstNode.');\n  }\n  return new TreeStreamImpl(root, node => streamContents(node, options));\n}\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nexport function streamAst(root, options) {\n  if (!root) {\n    throw new Error('Root node must be an AstNode.');\n  } else if ((options === null || options === void 0 ? void 0 : options.range) && !isAstNodeInRange(root, options.range)) {\n    // Return an empty stream if the root node isn't in range\n    return new TreeStreamImpl(root, () => []);\n  }\n  return new TreeStreamImpl(root, node => streamContents(node, options), {\n    includeRoot: true\n  });\n}\nfunction isAstNodeInRange(astNode, range) {\n  var _a;\n  if (!range) {\n    return true;\n  }\n  const nodeRange = (_a = astNode.$cstNode) === null || _a === void 0 ? void 0 : _a.range;\n  if (!nodeRange) {\n    return false;\n  }\n  return inRange(nodeRange, range);\n}\n/**\n * Create a stream of all cross-references that are held by the given AST node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nexport function streamReferences(node) {\n  return new StreamImpl(() => ({\n    keys: Object.keys(node),\n    keyIndex: 0,\n    arrayIndex: 0\n  }), state => {\n    while (state.keyIndex < state.keys.length) {\n      const property = state.keys[state.keyIndex];\n      if (!property.startsWith('$')) {\n        const value = node[property];\n        if (isReference(value)) {\n          state.keyIndex++;\n          return {\n            done: false,\n            value: {\n              reference: value,\n              container: node,\n              property\n            }\n          };\n        } else if (Array.isArray(value)) {\n          while (state.arrayIndex < value.length) {\n            const index = state.arrayIndex++;\n            const element = value[index];\n            if (isReference(element)) {\n              return {\n                done: false,\n                value: {\n                  reference: element,\n                  container: node,\n                  property,\n                  index\n                }\n              };\n            }\n          }\n          state.arrayIndex = 0;\n        }\n      }\n      state.keyIndex++;\n    }\n    return DONE_RESULT;\n  });\n}\n/**\n * Returns a Stream of references to the target node from the AstNode tree\n *\n * @param targetNode AstNode we are looking for\n * @param lookup AstNode where we search for references. If not provided, the root node of the document is used as the default value\n */\nexport function findLocalReferences(targetNode, lookup = getDocument(targetNode).parseResult.value) {\n  const refs = [];\n  streamAst(lookup).forEach(node => {\n    streamReferences(node).forEach(refInfo => {\n      if (refInfo.reference.ref === targetNode) {\n        refs.push(refInfo.reference);\n      }\n    });\n  });\n  return stream(refs);\n}\n/**\n * Assigns all mandatory AST properties to the specified node.\n *\n * @param reflection Reflection object used to gather mandatory properties for the node.\n * @param node Specified node is modified in place and properties are directly assigned.\n */\nexport function assignMandatoryProperties(reflection, node) {\n  const typeMetaData = reflection.getTypeMetaData(node.$type);\n  const genericNode = node;\n  for (const property of typeMetaData.properties) {\n    // Only set the value if the property is not already set and if it has a default value\n    if (property.defaultValue !== undefined && genericNode[property.name] === undefined) {\n      genericNode[property.name] = copyDefaultValue(property.defaultValue);\n    }\n  }\n}\nfunction copyDefaultValue(propertyType) {\n  if (Array.isArray(propertyType)) {\n    return [...propertyType.map(copyDefaultValue)];\n  } else {\n    return propertyType;\n  }\n}\n/**\n * Creates a deep copy of the specified AST node.\n * The resulting copy will only contain semantically relevant information, such as the `$type` property and AST properties.\n *\n * References are copied without resolved cross reference. The specified function is used to rebuild them.\n */\nexport function copyAstNode(node, buildReference) {\n  const copy = {\n    $type: node.$type\n  };\n  for (const [name, value] of Object.entries(node)) {\n    if (!name.startsWith('$')) {\n      if (isAstNode(value)) {\n        copy[name] = copyAstNode(value, buildReference);\n      } else if (isReference(value)) {\n        copy[name] = buildReference(copy, name, value.$refNode, value.$refText);\n      } else if (Array.isArray(value)) {\n        const copiedArray = [];\n        for (const element of value) {\n          if (isAstNode(element)) {\n            copiedArray.push(copyAstNode(element, buildReference));\n          } else if (isReference(element)) {\n            copiedArray.push(buildReference(copy, name, element.$refNode, element.$refText));\n          } else {\n            copiedArray.push(element);\n          }\n        }\n        copy[name] = copiedArray;\n      } else {\n        copy[name] = value;\n      }\n    }\n  }\n  linkContentToContainer(copy);\n  return copy;\n}","map":{"version":3,"names":["isAstNode","isReference","DONE_RESULT","stream","StreamImpl","TreeStreamImpl","inRange","linkContentToContainer","node","name","value","Object","entries","startsWith","Array","isArray","forEach","item","index","$container","$containerProperty","$containerIndex","getContainerOfType","typePredicate","undefined","hasContainerOfType","predicate","getDocument","rootNode","findRootNode","result","$document","Error","streamContents","options","range","keys","keyIndex","arrayIndex","state","length","property","isAstNodeInRange","done","element","streamAllContents","root","streamAst","includeRoot","astNode","nodeRange","_a","$cstNode","streamReferences","reference","container","findLocalReferences","targetNode","lookup","parseResult","refs","refInfo","ref","push","assignMandatoryProperties","reflection","typeMetaData","getTypeMetaData","$type","genericNode","properties","defaultValue","copyDefaultValue","propertyType","map","copyAstNode","buildReference","copy","$refNode","$refText","copiedArray"],"sources":["D:\\DBMS\\DBMS Project\\frontend\\node_modules\\langium\\src\\utils\\ast-utils.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Range } from 'vscode-languageserver-types';\r\nimport type { AstNode, AstReflection, CstNode, GenericAstNode, Mutable, PropertyType, Reference, ReferenceInfo } from '../syntax-tree.js';\r\nimport type { Stream, TreeStream } from './stream.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport { isAstNode, isReference } from '../syntax-tree.js';\r\nimport { DONE_RESULT, stream, StreamImpl, TreeStreamImpl } from './stream.js';\r\nimport { inRange } from './cst-utils.js';\r\n\r\n/**\r\n * Link the `$container` and other related properties of every AST node that is directly contained\r\n * in the given `node`.\r\n */\r\nexport function linkContentToContainer(node: AstNode): void {\r\n    for (const [name, value] of Object.entries(node)) {\r\n        if (!name.startsWith('$')) {\r\n            if (Array.isArray(value)) {\r\n                value.forEach((item, index) => {\r\n                    if (isAstNode(item)) {\r\n                        (item as Mutable<AstNode>).$container = node;\r\n                        (item as Mutable<AstNode>).$containerProperty = name;\r\n                        (item as Mutable<AstNode>).$containerIndex = index;\r\n                    }\r\n                });\r\n            } else if (isAstNode(value)) {\r\n                (value as Mutable<AstNode>).$container = node;\r\n                (value as Mutable<AstNode>).$containerProperty = name;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Walk along the hierarchy of containers from the given AST node to the root and return the first\r\n * node that matches the type predicate. If the start node itself matches, it is returned.\r\n * If no container matches, `undefined` is returned.\r\n */\r\nexport function getContainerOfType<T extends AstNode>(node: AstNode | undefined, typePredicate: (n: AstNode) => n is T): T | undefined {\r\n    let item = node;\r\n    while (item) {\r\n        if (typePredicate(item)) {\r\n            return item;\r\n        }\r\n        item = item.$container;\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Walk along the hierarchy of containers from the given AST node to the root and check for existence\r\n * of a container that matches the given predicate. The start node is included in the checks.\r\n */\r\nexport function hasContainerOfType(node: AstNode | undefined, predicate: (n: AstNode) => boolean): boolean {\r\n    let item = node;\r\n    while (item) {\r\n        if (predicate(item)) {\r\n            return true;\r\n        }\r\n        item = item.$container;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Retrieve the document in which the given AST node is contained. A reference to the document is\r\n * usually held by the root node of the AST.\r\n *\r\n * @throws an error if the node is not contained in a document.\r\n */\r\nexport function getDocument<T extends AstNode = AstNode>(node: AstNode): LangiumDocument<T> {\r\n    const rootNode = findRootNode(node);\r\n    const result = rootNode.$document;\r\n    if (!result) {\r\n        throw new Error('AST node has no document.');\r\n    }\r\n    return result as LangiumDocument<T>;\r\n}\r\n\r\n/**\r\n * Returns the root node of the given AST node by following the `$container` references.\r\n */\r\nexport function findRootNode(node: AstNode): AstNode {\r\n    while (node.$container) {\r\n        node = node.$container;\r\n    }\r\n    return node;\r\n}\r\n\r\nexport interface AstStreamOptions {\r\n    /**\r\n     * Optional target range that the nodes in the stream need to intersect\r\n     */\r\n    range?: Range\r\n}\r\n\r\n/**\r\n * Create a stream of all AST nodes that are directly contained in the given node. This includes\r\n * single-valued as well as multi-valued (array) properties.\r\n */\r\nexport function streamContents(node: AstNode, options?: AstStreamOptions): Stream<AstNode> {\r\n    if (!node) {\r\n        throw new Error('Node must be an AstNode.');\r\n    }\r\n    const range = options?.range;\r\n    type State = { keys: string[], keyIndex: number, arrayIndex: number };\r\n    return new StreamImpl<State, AstNode>(() => ({\r\n        keys: Object.keys(node),\r\n        keyIndex: 0,\r\n        arrayIndex: 0\r\n    }), state => {\r\n        while (state.keyIndex < state.keys.length) {\r\n            const property = state.keys[state.keyIndex];\r\n            if (!property.startsWith('$')) {\r\n                const value = (node as GenericAstNode)[property];\r\n                if (isAstNode(value)) {\r\n                    state.keyIndex++;\r\n                    if (isAstNodeInRange(value, range)) {\r\n                        return { done: false, value };\r\n                    }\r\n                } else if (Array.isArray(value)) {\r\n                    while (state.arrayIndex < value.length) {\r\n                        const index = state.arrayIndex++;\r\n                        const element = value[index];\r\n                        if (isAstNode(element) && isAstNodeInRange(element, range)) {\r\n                            return { done: false, value: element };\r\n                        }\r\n                    }\r\n                    state.arrayIndex = 0;\r\n                }\r\n            }\r\n            state.keyIndex++;\r\n        }\r\n        return DONE_RESULT;\r\n    });\r\n}\r\n\r\n/**\r\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node.\r\n * This does not include the root node itself.\r\n */\r\nexport function streamAllContents(root: AstNode, options?: AstStreamOptions): TreeStream<AstNode> {\r\n    if (!root) {\r\n        throw new Error('Root node must be an AstNode.');\r\n    }\r\n    return new TreeStreamImpl(root, node => streamContents(node, options));\r\n}\r\n\r\n/**\r\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node,\r\n * including the root node itself.\r\n */\r\nexport function streamAst(root: AstNode, options?: AstStreamOptions): TreeStream<AstNode> {\r\n    if (!root) {\r\n        throw new Error('Root node must be an AstNode.');\r\n    } else if (options?.range && !isAstNodeInRange(root, options.range)) {\r\n        // Return an empty stream if the root node isn't in range\r\n        return new TreeStreamImpl(root, () => []);\r\n    }\r\n    return new TreeStreamImpl(root, node => streamContents(node, options), { includeRoot: true });\r\n}\r\n\r\nfunction isAstNodeInRange(astNode: AstNode, range?: Range): boolean {\r\n    if (!range) {\r\n        return true;\r\n    }\r\n    const nodeRange = astNode.$cstNode?.range;\r\n    if (!nodeRange) {\r\n        return false;\r\n    }\r\n    return inRange(nodeRange, range);\r\n}\r\n\r\n/**\r\n * Create a stream of all cross-references that are held by the given AST node. This includes\r\n * single-valued as well as multi-valued (array) properties.\r\n */\r\nexport function streamReferences(node: AstNode): Stream<ReferenceInfo> {\r\n    type State = { keys: string[], keyIndex: number, arrayIndex: number };\r\n    return new StreamImpl<State, ReferenceInfo>(() => ({\r\n        keys: Object.keys(node),\r\n        keyIndex: 0,\r\n        arrayIndex: 0\r\n    }), state => {\r\n        while (state.keyIndex < state.keys.length) {\r\n            const property = state.keys[state.keyIndex];\r\n            if (!property.startsWith('$')) {\r\n                const value = (node as GenericAstNode)[property];\r\n                if (isReference(value)) {\r\n                    state.keyIndex++;\r\n                    return { done: false, value: { reference: value, container: node, property } };\r\n                } else if (Array.isArray(value)) {\r\n                    while (state.arrayIndex < value.length) {\r\n                        const index = state.arrayIndex++;\r\n                        const element = value[index];\r\n                        if (isReference(element)) {\r\n                            return { done: false, value: { reference: element, container: node, property, index } };\r\n                        }\r\n                    }\r\n                    state.arrayIndex = 0;\r\n                }\r\n            }\r\n            state.keyIndex++;\r\n        }\r\n        return DONE_RESULT;\r\n    });\r\n}\r\n\r\n/**\r\n * Returns a Stream of references to the target node from the AstNode tree\r\n *\r\n * @param targetNode AstNode we are looking for\r\n * @param lookup AstNode where we search for references. If not provided, the root node of the document is used as the default value\r\n */\r\nexport function findLocalReferences(targetNode: AstNode, lookup = getDocument(targetNode).parseResult.value): Stream<Reference> {\r\n    const refs: Reference[] = [];\r\n    streamAst(lookup).forEach(node => {\r\n        streamReferences(node).forEach(refInfo => {\r\n            if (refInfo.reference.ref === targetNode) {\r\n                refs.push(refInfo.reference);\r\n            }\r\n        });\r\n    });\r\n    return stream(refs);\r\n}\r\n\r\n/**\r\n * Assigns all mandatory AST properties to the specified node.\r\n *\r\n * @param reflection Reflection object used to gather mandatory properties for the node.\r\n * @param node Specified node is modified in place and properties are directly assigned.\r\n */\r\nexport function assignMandatoryProperties(reflection: AstReflection, node: AstNode): void {\r\n    const typeMetaData = reflection.getTypeMetaData(node.$type);\r\n    const genericNode = node as GenericAstNode;\r\n    for (const property of typeMetaData.properties) {\r\n        // Only set the value if the property is not already set and if it has a default value\r\n        if (property.defaultValue !== undefined && genericNode[property.name] === undefined) {\r\n            genericNode[property.name] = copyDefaultValue(property.defaultValue);\r\n        }\r\n    }\r\n}\r\n\r\nfunction copyDefaultValue(propertyType: PropertyType): PropertyType {\r\n    if (Array.isArray(propertyType)) {\r\n        return [...propertyType.map(copyDefaultValue)];\r\n    } else {\r\n        return propertyType;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a deep copy of the specified AST node.\r\n * The resulting copy will only contain semantically relevant information, such as the `$type` property and AST properties.\r\n *\r\n * References are copied without resolved cross reference. The specified function is used to rebuild them.\r\n */\r\nexport function copyAstNode<T extends AstNode = AstNode>(node: T, buildReference: (node: AstNode, property: string, refNode: CstNode | undefined, refText: string) => Reference<AstNode>): T {\r\n    const copy: GenericAstNode = { $type: node.$type };\r\n\r\n    for (const [name, value] of Object.entries(node)) {\r\n        if (!name.startsWith('$')) {\r\n            if (isAstNode(value)) {\r\n                copy[name] = copyAstNode(value, buildReference);\r\n            } else if (isReference(value)) {\r\n                copy[name] = buildReference(\r\n                    copy,\r\n                    name,\r\n                    value.$refNode,\r\n                    value.$refText\r\n                );\r\n            } else if (Array.isArray(value)) {\r\n                const copiedArray: unknown[] = [];\r\n                for (const element of value) {\r\n                    if (isAstNode(element)) {\r\n                        copiedArray.push(copyAstNode(element, buildReference));\r\n                    } else if (isReference(element)) {\r\n                        copiedArray.push(\r\n                            buildReference(\r\n                                copy,\r\n                                name,\r\n                                element.$refNode,\r\n                                element.$refText\r\n                            )\r\n                        );\r\n                    } else {\r\n                        copiedArray.push(element);\r\n                    }\r\n                }\r\n                copy[name] = copiedArray;\r\n            } else {\r\n                copy[name] = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    linkContentToContainer(copy);\r\n    return copy as unknown as T;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}