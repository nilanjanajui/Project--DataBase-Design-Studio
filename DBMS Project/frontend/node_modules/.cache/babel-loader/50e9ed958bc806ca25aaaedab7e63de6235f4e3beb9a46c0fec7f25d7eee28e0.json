{"ast":null,"code":"/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { getDocument } from '../utils/ast-utils.js';\nimport { ContextCache } from '../utils/caching.js';\nimport { CancellationToken } from '../utils/cancellation.js';\nimport { stream } from '../utils/stream.js';\nimport { UriUtils } from '../utils/uri-utils.js';\nexport class DefaultIndexManager {\n  constructor(services) {\n    /**\n     * The symbol index stores all `AstNodeDescription` items exported by a document.\n     * The key used in this map is the string representation of the specific document URI.\n     */\n    this.symbolIndex = new Map();\n    /**\n     * This is a cache for the `allElements()` method.\n     * It caches the descriptions from `symbolIndex` grouped by types.\n     */\n    this.symbolByTypeIndex = new ContextCache();\n    /**\n     * This index keeps track of all `ReferenceDescription` items exported by a document.\n     * This is used to compute which elements are affected by a document change\n     * and for finding references to an AST node.\n     */\n    this.referenceIndex = new Map();\n    this.documents = services.workspace.LangiumDocuments;\n    this.serviceRegistry = services.ServiceRegistry;\n    this.astReflection = services.AstReflection;\n  }\n  findAllReferences(targetNode, astNodePath) {\n    const targetDocUri = getDocument(targetNode).uri;\n    const result = [];\n    this.referenceIndex.forEach(docRefs => {\n      docRefs.forEach(refDescr => {\n        if (UriUtils.equals(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {\n          result.push(refDescr);\n        }\n      });\n    });\n    return stream(result);\n  }\n  allElements(nodeType, uris) {\n    let documentUris = stream(this.symbolIndex.keys());\n    if (uris) {\n      documentUris = documentUris.filter(uri => !uris || uris.has(uri));\n    }\n    return documentUris.map(uri => this.getFileDescriptions(uri, nodeType)).flat();\n  }\n  getFileDescriptions(uri, nodeType) {\n    var _a;\n    if (!nodeType) {\n      return (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];\n    }\n    const descriptions = this.symbolByTypeIndex.get(uri, nodeType, () => {\n      var _a;\n      const allFileDescriptions = (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];\n      return allFileDescriptions.filter(e => this.astReflection.isSubtype(e.type, nodeType));\n    });\n    return descriptions;\n  }\n  remove(uri) {\n    const uriString = uri.toString();\n    this.symbolIndex.delete(uriString);\n    this.symbolByTypeIndex.clear(uriString);\n    this.referenceIndex.delete(uriString);\n  }\n  async updateContent(document, cancelToken = CancellationToken.None) {\n    const services = this.serviceRegistry.getServices(document.uri);\n    const exports = await services.references.ScopeComputation.computeExports(document, cancelToken);\n    const uri = document.uri.toString();\n    this.symbolIndex.set(uri, exports);\n    this.symbolByTypeIndex.clear(uri);\n  }\n  async updateReferences(document, cancelToken = CancellationToken.None) {\n    const services = this.serviceRegistry.getServices(document.uri);\n    const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);\n    this.referenceIndex.set(document.uri.toString(), indexData);\n  }\n  isAffected(document, changedUris) {\n    const references = this.referenceIndex.get(document.uri.toString());\n    if (!references) {\n      return false;\n    }\n    return references.some(ref => !ref.local && changedUris.has(ref.targetUri.toString()));\n  }\n}","map":{"version":3,"names":["getDocument","ContextCache","CancellationToken","stream","UriUtils","DefaultIndexManager","constructor","services","symbolIndex","Map","symbolByTypeIndex","referenceIndex","documents","workspace","LangiumDocuments","serviceRegistry","ServiceRegistry","astReflection","AstReflection","findAllReferences","targetNode","astNodePath","targetDocUri","uri","result","forEach","docRefs","refDescr","equals","targetUri","targetPath","push","allElements","nodeType","uris","documentUris","keys","filter","has","map","getFileDescriptions","flat","_a","get","descriptions","allFileDescriptions","e","isSubtype","type","remove","uriString","toString","delete","clear","updateContent","document","cancelToken","None","getServices","exports","references","ScopeComputation","computeExports","set","updateReferences","indexData","ReferenceDescriptionProvider","createDescriptions","isAffected","changedUris","some","ref","local"],"sources":["D:\\DBMS\\DBMS Project\\frontend\\node_modules\\langium\\src\\workspace\\index-manager.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { ServiceRegistry } from '../service-registry.js';\r\nimport type { LangiumSharedCoreServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription, AstReflection } from '../syntax-tree.js';\r\nimport { getDocument } from '../utils/ast-utils.js';\r\nimport { ContextCache } from '../utils/caching.js';\r\nimport { CancellationToken } from '../utils/cancellation.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport type { URI } from '../utils/uri-utils.js';\r\nimport { UriUtils } from '../utils/uri-utils.js';\r\nimport type { ReferenceDescription } from './ast-descriptions.js';\r\nimport type { LangiumDocument, LangiumDocuments } from './documents.js';\r\n\r\n/**\r\n * The index manager is responsible for keeping metadata about symbols and cross-references\r\n * in the workspace. It is used to look up symbols in the global scope, mostly during linking\r\n * and completion. This service is shared between all languages of a language server.\r\n */\r\nexport interface IndexManager {\r\n\r\n    /**\r\n     * Removes the specified document URI from the index.\r\n     * Necessary when documents are deleted and not referenceable anymore.\r\n     *\r\n     * @param uri The URI of the document for which index data shall be removed\r\n     */\r\n    remove(uri: URI): void;\r\n\r\n    /**\r\n     * Updates the information about the exportable content of a document inside the index.\r\n     *\r\n     * @param document Document to be updated\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    updateContent(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;\r\n\r\n    /**\r\n     * Updates the information about the cross-references of a document inside the index.\r\n     *\r\n     * @param document Document to be updated\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    updateReferences(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;\r\n\r\n    /**\r\n     * Determine whether the given document could be affected by changes of the documents\r\n     * identified by the given URIs (second parameter). The document is typically regarded as\r\n     * affected if it contains a reference to any of the changed files.\r\n     *\r\n     * @param document Document to check whether it's affected\r\n     * @param changedUris URIs of the changed documents\r\n     */\r\n    isAffected(document: LangiumDocument, changedUris: Set<string>): boolean;\r\n\r\n    /**\r\n     * Compute a list of all exported elements, optionally filtered using a type identifier and document URIs.\r\n     *\r\n     * @param nodeType The type to filter with, or `undefined` to return descriptions of all types.\r\n     * @param uris If specified, only returns elements from the given URIs.\r\n     * @returns a `Stream` containing all globally visible nodes (of a given type).\r\n     */\r\n    allElements(nodeType?: string, uris?: Set<string>): Stream<AstNodeDescription>;\r\n\r\n    /**\r\n     * Returns all known references that are pointing to the given `targetNode`.\r\n     *\r\n     * @param targetNode the `AstNode` to look up references for\r\n     * @param astNodePath the path that points to the `targetNode` inside the document. See also `AstNodeLocator`\r\n     *\r\n     * @returns a `Stream` of references that are targeting the `targetNode`\r\n     */\r\n    findAllReferences(targetNode: AstNode, astNodePath: string): Stream<ReferenceDescription>;\r\n\r\n}\r\n\r\nexport class DefaultIndexManager implements IndexManager {\r\n\r\n    protected readonly serviceRegistry: ServiceRegistry;\r\n    protected readonly documents: LangiumDocuments;\r\n    protected readonly astReflection: AstReflection;\r\n\r\n    /**\r\n     * The symbol index stores all `AstNodeDescription` items exported by a document.\r\n     * The key used in this map is the string representation of the specific document URI.\r\n     */\r\n    protected readonly symbolIndex = new Map<string, AstNodeDescription[]>();\r\n    /**\r\n     * This is a cache for the `allElements()` method.\r\n     * It caches the descriptions from `symbolIndex` grouped by types.\r\n     */\r\n    protected readonly symbolByTypeIndex = new ContextCache<string, string, AstNodeDescription[]>();\r\n    /**\r\n     * This index keeps track of all `ReferenceDescription` items exported by a document.\r\n     * This is used to compute which elements are affected by a document change\r\n     * and for finding references to an AST node.\r\n     */\r\n    protected readonly referenceIndex = new Map<string, ReferenceDescription[]>();\r\n\r\n    constructor(services: LangiumSharedCoreServices) {\r\n        this.documents = services.workspace.LangiumDocuments;\r\n        this.serviceRegistry = services.ServiceRegistry;\r\n        this.astReflection = services.AstReflection;\r\n    }\r\n\r\n    findAllReferences(targetNode: AstNode, astNodePath: string): Stream<ReferenceDescription> {\r\n        const targetDocUri = getDocument(targetNode).uri;\r\n        const result: ReferenceDescription[] = [];\r\n        this.referenceIndex.forEach(docRefs => {\r\n            docRefs.forEach(refDescr => {\r\n                if (UriUtils.equals(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {\r\n                    result.push(refDescr);\r\n                }\r\n            });\r\n        });\r\n        return stream(result);\r\n    }\r\n\r\n    allElements(nodeType?: string, uris?: Set<string>): Stream<AstNodeDescription> {\r\n        let documentUris = stream(this.symbolIndex.keys());\r\n        if (uris) {\r\n            documentUris = documentUris.filter(uri => !uris || uris.has(uri));\r\n        }\r\n        return documentUris\r\n            .map(uri => this.getFileDescriptions(uri, nodeType))\r\n            .flat();\r\n    }\r\n\r\n    protected getFileDescriptions(uri: string, nodeType?: string): AstNodeDescription[] {\r\n        if (!nodeType) {\r\n            return this.symbolIndex.get(uri) ?? [];\r\n        }\r\n        const descriptions = this.symbolByTypeIndex.get(uri, nodeType, () => {\r\n            const allFileDescriptions = this.symbolIndex.get(uri) ?? [];\r\n            return allFileDescriptions.filter(e => this.astReflection.isSubtype(e.type, nodeType));\r\n        });\r\n        return descriptions;\r\n    }\r\n\r\n    remove(uri: URI): void {\r\n        const uriString = uri.toString();\r\n        this.symbolIndex.delete(uriString);\r\n        this.symbolByTypeIndex.clear(uriString);\r\n        this.referenceIndex.delete(uriString);\r\n    }\r\n\r\n    async updateContent(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<void> {\r\n        const services = this.serviceRegistry.getServices(document.uri);\r\n        const exports = await services.references.ScopeComputation.computeExports(document, cancelToken);\r\n        const uri = document.uri.toString();\r\n        this.symbolIndex.set(uri, exports);\r\n        this.symbolByTypeIndex.clear(uri);\r\n    }\r\n\r\n    async updateReferences(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<void> {\r\n        const services = this.serviceRegistry.getServices(document.uri);\r\n        const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);\r\n        this.referenceIndex.set(document.uri.toString(), indexData);\r\n    }\r\n\r\n    isAffected(document: LangiumDocument, changedUris: Set<string>): boolean {\r\n        const references = this.referenceIndex.get(document.uri.toString());\r\n        if (!references) {\r\n            return false;\r\n        }\r\n        return references.some(ref => !ref.local && changedUris.has(ref.targetUri.toString()));\r\n    }\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}