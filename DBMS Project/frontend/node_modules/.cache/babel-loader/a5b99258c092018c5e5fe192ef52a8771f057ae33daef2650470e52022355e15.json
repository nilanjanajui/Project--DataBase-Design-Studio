{"ast":null,"code":"/******************************************************************************\n * This file was generated by langium-cli 3.3.0.\n * DO NOT EDIT MANUALLY!\n ******************************************************************************/\nimport { AbstractAstReflection } from '../../syntax-tree.js';\nexport const LangiumGrammarTerminals = {\n  ID: /\\^?[_a-zA-Z][\\w_]*/,\n  STRING: /\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*'/,\n  NUMBER: /NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity)/,\n  RegexLiteral: /\\/(?![*+?])(?:[^\\r\\n\\[/\\\\]|\\\\.|\\[(?:[^\\r\\n\\]\\\\]|\\\\.)*\\])+\\/[a-z]*/,\n  WS: /\\s+/,\n  ML_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\n  SL_COMMENT: /\\/\\/[^\\n\\r]*/\n};\nexport const AbstractRule = 'AbstractRule';\nexport function isAbstractRule(item) {\n  return reflection.isInstance(item, AbstractRule);\n}\nexport const AbstractType = 'AbstractType';\nexport function isAbstractType(item) {\n  return reflection.isInstance(item, AbstractType);\n}\nexport const Condition = 'Condition';\nexport function isCondition(item) {\n  return reflection.isInstance(item, Condition);\n}\nexport function isFeatureName(item) {\n  return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || typeof item === 'string' && /\\^?[_a-zA-Z][\\w_]*/.test(item);\n}\nexport function isPrimitiveType(item) {\n  return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';\n}\nexport const TypeDefinition = 'TypeDefinition';\nexport function isTypeDefinition(item) {\n  return reflection.isInstance(item, TypeDefinition);\n}\nexport const ValueLiteral = 'ValueLiteral';\nexport function isValueLiteral(item) {\n  return reflection.isInstance(item, ValueLiteral);\n}\nexport const AbstractElement = 'AbstractElement';\nexport function isAbstractElement(item) {\n  return reflection.isInstance(item, AbstractElement);\n}\nexport const ArrayLiteral = 'ArrayLiteral';\nexport function isArrayLiteral(item) {\n  return reflection.isInstance(item, ArrayLiteral);\n}\nexport const ArrayType = 'ArrayType';\nexport function isArrayType(item) {\n  return reflection.isInstance(item, ArrayType);\n}\nexport const BooleanLiteral = 'BooleanLiteral';\nexport function isBooleanLiteral(item) {\n  return reflection.isInstance(item, BooleanLiteral);\n}\nexport const Conjunction = 'Conjunction';\nexport function isConjunction(item) {\n  return reflection.isInstance(item, Conjunction);\n}\nexport const Disjunction = 'Disjunction';\nexport function isDisjunction(item) {\n  return reflection.isInstance(item, Disjunction);\n}\nexport const Grammar = 'Grammar';\nexport function isGrammar(item) {\n  return reflection.isInstance(item, Grammar);\n}\nexport const GrammarImport = 'GrammarImport';\nexport function isGrammarImport(item) {\n  return reflection.isInstance(item, GrammarImport);\n}\nexport const InferredType = 'InferredType';\nexport function isInferredType(item) {\n  return reflection.isInstance(item, InferredType);\n}\nexport const Interface = 'Interface';\nexport function isInterface(item) {\n  return reflection.isInstance(item, Interface);\n}\nexport const NamedArgument = 'NamedArgument';\nexport function isNamedArgument(item) {\n  return reflection.isInstance(item, NamedArgument);\n}\nexport const Negation = 'Negation';\nexport function isNegation(item) {\n  return reflection.isInstance(item, Negation);\n}\nexport const NumberLiteral = 'NumberLiteral';\nexport function isNumberLiteral(item) {\n  return reflection.isInstance(item, NumberLiteral);\n}\nexport const Parameter = 'Parameter';\nexport function isParameter(item) {\n  return reflection.isInstance(item, Parameter);\n}\nexport const ParameterReference = 'ParameterReference';\nexport function isParameterReference(item) {\n  return reflection.isInstance(item, ParameterReference);\n}\nexport const ParserRule = 'ParserRule';\nexport function isParserRule(item) {\n  return reflection.isInstance(item, ParserRule);\n}\nexport const ReferenceType = 'ReferenceType';\nexport function isReferenceType(item) {\n  return reflection.isInstance(item, ReferenceType);\n}\nexport const ReturnType = 'ReturnType';\nexport function isReturnType(item) {\n  return reflection.isInstance(item, ReturnType);\n}\nexport const SimpleType = 'SimpleType';\nexport function isSimpleType(item) {\n  return reflection.isInstance(item, SimpleType);\n}\nexport const StringLiteral = 'StringLiteral';\nexport function isStringLiteral(item) {\n  return reflection.isInstance(item, StringLiteral);\n}\nexport const TerminalRule = 'TerminalRule';\nexport function isTerminalRule(item) {\n  return reflection.isInstance(item, TerminalRule);\n}\nexport const Type = 'Type';\nexport function isType(item) {\n  return reflection.isInstance(item, Type);\n}\nexport const TypeAttribute = 'TypeAttribute';\nexport function isTypeAttribute(item) {\n  return reflection.isInstance(item, TypeAttribute);\n}\nexport const UnionType = 'UnionType';\nexport function isUnionType(item) {\n  return reflection.isInstance(item, UnionType);\n}\nexport const Action = 'Action';\nexport function isAction(item) {\n  return reflection.isInstance(item, Action);\n}\nexport const Alternatives = 'Alternatives';\nexport function isAlternatives(item) {\n  return reflection.isInstance(item, Alternatives);\n}\nexport const Assignment = 'Assignment';\nexport function isAssignment(item) {\n  return reflection.isInstance(item, Assignment);\n}\nexport const CharacterRange = 'CharacterRange';\nexport function isCharacterRange(item) {\n  return reflection.isInstance(item, CharacterRange);\n}\nexport const CrossReference = 'CrossReference';\nexport function isCrossReference(item) {\n  return reflection.isInstance(item, CrossReference);\n}\nexport const EndOfFile = 'EndOfFile';\nexport function isEndOfFile(item) {\n  return reflection.isInstance(item, EndOfFile);\n}\nexport const Group = 'Group';\nexport function isGroup(item) {\n  return reflection.isInstance(item, Group);\n}\nexport const Keyword = 'Keyword';\nexport function isKeyword(item) {\n  return reflection.isInstance(item, Keyword);\n}\nexport const NegatedToken = 'NegatedToken';\nexport function isNegatedToken(item) {\n  return reflection.isInstance(item, NegatedToken);\n}\nexport const RegexToken = 'RegexToken';\nexport function isRegexToken(item) {\n  return reflection.isInstance(item, RegexToken);\n}\nexport const RuleCall = 'RuleCall';\nexport function isRuleCall(item) {\n  return reflection.isInstance(item, RuleCall);\n}\nexport const TerminalAlternatives = 'TerminalAlternatives';\nexport function isTerminalAlternatives(item) {\n  return reflection.isInstance(item, TerminalAlternatives);\n}\nexport const TerminalGroup = 'TerminalGroup';\nexport function isTerminalGroup(item) {\n  return reflection.isInstance(item, TerminalGroup);\n}\nexport const TerminalRuleCall = 'TerminalRuleCall';\nexport function isTerminalRuleCall(item) {\n  return reflection.isInstance(item, TerminalRuleCall);\n}\nexport const UnorderedGroup = 'UnorderedGroup';\nexport function isUnorderedGroup(item) {\n  return reflection.isInstance(item, UnorderedGroup);\n}\nexport const UntilToken = 'UntilToken';\nexport function isUntilToken(item) {\n  return reflection.isInstance(item, UntilToken);\n}\nexport const Wildcard = 'Wildcard';\nexport function isWildcard(item) {\n  return reflection.isInstance(item, Wildcard);\n}\nexport class LangiumGrammarAstReflection extends AbstractAstReflection {\n  getAllTypes() {\n    return [AbstractElement, AbstractRule, AbstractType, Action, Alternatives, ArrayLiteral, ArrayType, Assignment, BooleanLiteral, CharacterRange, Condition, Conjunction, CrossReference, Disjunction, EndOfFile, Grammar, GrammarImport, Group, InferredType, Interface, Keyword, NamedArgument, NegatedToken, Negation, NumberLiteral, Parameter, ParameterReference, ParserRule, ReferenceType, RegexToken, ReturnType, RuleCall, SimpleType, StringLiteral, TerminalAlternatives, TerminalGroup, TerminalRule, TerminalRuleCall, Type, TypeAttribute, TypeDefinition, UnionType, UnorderedGroup, UntilToken, ValueLiteral, Wildcard];\n  }\n  computeIsSubtype(subtype, supertype) {\n    switch (subtype) {\n      case Action:\n      case Alternatives:\n      case Assignment:\n      case CharacterRange:\n      case CrossReference:\n      case EndOfFile:\n      case Group:\n      case Keyword:\n      case NegatedToken:\n      case RegexToken:\n      case RuleCall:\n      case TerminalAlternatives:\n      case TerminalGroup:\n      case TerminalRuleCall:\n      case UnorderedGroup:\n      case UntilToken:\n      case Wildcard:\n        {\n          return this.isSubtype(AbstractElement, supertype);\n        }\n      case ArrayLiteral:\n      case NumberLiteral:\n      case StringLiteral:\n        {\n          return this.isSubtype(ValueLiteral, supertype);\n        }\n      case ArrayType:\n      case ReferenceType:\n      case SimpleType:\n      case UnionType:\n        {\n          return this.isSubtype(TypeDefinition, supertype);\n        }\n      case BooleanLiteral:\n        {\n          return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);\n        }\n      case Conjunction:\n      case Disjunction:\n      case Negation:\n      case ParameterReference:\n        {\n          return this.isSubtype(Condition, supertype);\n        }\n      case InferredType:\n      case Interface:\n      case Type:\n        {\n          return this.isSubtype(AbstractType, supertype);\n        }\n      case ParserRule:\n        {\n          return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);\n        }\n      case TerminalRule:\n        {\n          return this.isSubtype(AbstractRule, supertype);\n        }\n      default:\n        {\n          return false;\n        }\n    }\n  }\n  getReferenceType(refInfo) {\n    const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n    switch (referenceId) {\n      case 'Action:type':\n      case 'CrossReference:type':\n      case 'Interface:superTypes':\n      case 'ParserRule:returnType':\n      case 'SimpleType:typeRef':\n        {\n          return AbstractType;\n        }\n      case 'Grammar:hiddenTokens':\n      case 'ParserRule:hiddenTokens':\n      case 'RuleCall:rule':\n        {\n          return AbstractRule;\n        }\n      case 'Grammar:usedGrammars':\n        {\n          return Grammar;\n        }\n      case 'NamedArgument:parameter':\n      case 'ParameterReference:parameter':\n        {\n          return Parameter;\n        }\n      case 'TerminalRuleCall:rule':\n        {\n          return TerminalRule;\n        }\n      default:\n        {\n          throw new Error(`${referenceId} is not a valid reference id.`);\n        }\n    }\n  }\n  getTypeMetaData(type) {\n    switch (type) {\n      case AbstractElement:\n        {\n          return {\n            name: AbstractElement,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'lookahead'\n            }]\n          };\n        }\n      case ArrayLiteral:\n        {\n          return {\n            name: ArrayLiteral,\n            properties: [{\n              name: 'elements',\n              defaultValue: []\n            }]\n          };\n        }\n      case ArrayType:\n        {\n          return {\n            name: ArrayType,\n            properties: [{\n              name: 'elementType'\n            }]\n          };\n        }\n      case BooleanLiteral:\n        {\n          return {\n            name: BooleanLiteral,\n            properties: [{\n              name: 'true',\n              defaultValue: false\n            }]\n          };\n        }\n      case Conjunction:\n        {\n          return {\n            name: Conjunction,\n            properties: [{\n              name: 'left'\n            }, {\n              name: 'right'\n            }]\n          };\n        }\n      case Disjunction:\n        {\n          return {\n            name: Disjunction,\n            properties: [{\n              name: 'left'\n            }, {\n              name: 'right'\n            }]\n          };\n        }\n      case Grammar:\n        {\n          return {\n            name: Grammar,\n            properties: [{\n              name: 'definesHiddenTokens',\n              defaultValue: false\n            }, {\n              name: 'hiddenTokens',\n              defaultValue: []\n            }, {\n              name: 'imports',\n              defaultValue: []\n            }, {\n              name: 'interfaces',\n              defaultValue: []\n            }, {\n              name: 'isDeclared',\n              defaultValue: false\n            }, {\n              name: 'name'\n            }, {\n              name: 'rules',\n              defaultValue: []\n            }, {\n              name: 'types',\n              defaultValue: []\n            }, {\n              name: 'usedGrammars',\n              defaultValue: []\n            }]\n          };\n        }\n      case GrammarImport:\n        {\n          return {\n            name: GrammarImport,\n            properties: [{\n              name: 'path'\n            }]\n          };\n        }\n      case InferredType:\n        {\n          return {\n            name: InferredType,\n            properties: [{\n              name: 'name'\n            }]\n          };\n        }\n      case Interface:\n        {\n          return {\n            name: Interface,\n            properties: [{\n              name: 'attributes',\n              defaultValue: []\n            }, {\n              name: 'name'\n            }, {\n              name: 'superTypes',\n              defaultValue: []\n            }]\n          };\n        }\n      case NamedArgument:\n        {\n          return {\n            name: NamedArgument,\n            properties: [{\n              name: 'calledByName',\n              defaultValue: false\n            }, {\n              name: 'parameter'\n            }, {\n              name: 'value'\n            }]\n          };\n        }\n      case Negation:\n        {\n          return {\n            name: Negation,\n            properties: [{\n              name: 'value'\n            }]\n          };\n        }\n      case NumberLiteral:\n        {\n          return {\n            name: NumberLiteral,\n            properties: [{\n              name: 'value'\n            }]\n          };\n        }\n      case Parameter:\n        {\n          return {\n            name: Parameter,\n            properties: [{\n              name: 'name'\n            }]\n          };\n        }\n      case ParameterReference:\n        {\n          return {\n            name: ParameterReference,\n            properties: [{\n              name: 'parameter'\n            }]\n          };\n        }\n      case ParserRule:\n        {\n          return {\n            name: ParserRule,\n            properties: [{\n              name: 'dataType'\n            }, {\n              name: 'definesHiddenTokens',\n              defaultValue: false\n            }, {\n              name: 'definition'\n            }, {\n              name: 'entry',\n              defaultValue: false\n            }, {\n              name: 'fragment',\n              defaultValue: false\n            }, {\n              name: 'hiddenTokens',\n              defaultValue: []\n            }, {\n              name: 'inferredType'\n            }, {\n              name: 'name'\n            }, {\n              name: 'parameters',\n              defaultValue: []\n            }, {\n              name: 'returnType'\n            }, {\n              name: 'wildcard',\n              defaultValue: false\n            }]\n          };\n        }\n      case ReferenceType:\n        {\n          return {\n            name: ReferenceType,\n            properties: [{\n              name: 'referenceType'\n            }]\n          };\n        }\n      case ReturnType:\n        {\n          return {\n            name: ReturnType,\n            properties: [{\n              name: 'name'\n            }]\n          };\n        }\n      case SimpleType:\n        {\n          return {\n            name: SimpleType,\n            properties: [{\n              name: 'primitiveType'\n            }, {\n              name: 'stringType'\n            }, {\n              name: 'typeRef'\n            }]\n          };\n        }\n      case StringLiteral:\n        {\n          return {\n            name: StringLiteral,\n            properties: [{\n              name: 'value'\n            }]\n          };\n        }\n      case TerminalRule:\n        {\n          return {\n            name: TerminalRule,\n            properties: [{\n              name: 'definition'\n            }, {\n              name: 'fragment',\n              defaultValue: false\n            }, {\n              name: 'hidden',\n              defaultValue: false\n            }, {\n              name: 'name'\n            }, {\n              name: 'type'\n            }]\n          };\n        }\n      case Type:\n        {\n          return {\n            name: Type,\n            properties: [{\n              name: 'name'\n            }, {\n              name: 'type'\n            }]\n          };\n        }\n      case TypeAttribute:\n        {\n          return {\n            name: TypeAttribute,\n            properties: [{\n              name: 'defaultValue'\n            }, {\n              name: 'isOptional',\n              defaultValue: false\n            }, {\n              name: 'name'\n            }, {\n              name: 'type'\n            }]\n          };\n        }\n      case UnionType:\n        {\n          return {\n            name: UnionType,\n            properties: [{\n              name: 'types',\n              defaultValue: []\n            }]\n          };\n        }\n      case Action:\n        {\n          return {\n            name: Action,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'feature'\n            }, {\n              name: 'inferredType'\n            }, {\n              name: 'lookahead'\n            }, {\n              name: 'operator'\n            }, {\n              name: 'type'\n            }]\n          };\n        }\n      case Alternatives:\n        {\n          return {\n            name: Alternatives,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'elements',\n              defaultValue: []\n            }, {\n              name: 'lookahead'\n            }]\n          };\n        }\n      case Assignment:\n        {\n          return {\n            name: Assignment,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'feature'\n            }, {\n              name: 'lookahead'\n            }, {\n              name: 'operator'\n            }, {\n              name: 'terminal'\n            }]\n          };\n        }\n      case CharacterRange:\n        {\n          return {\n            name: CharacterRange,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'left'\n            }, {\n              name: 'lookahead'\n            }, {\n              name: 'right'\n            }]\n          };\n        }\n      case CrossReference:\n        {\n          return {\n            name: CrossReference,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'deprecatedSyntax',\n              defaultValue: false\n            }, {\n              name: 'lookahead'\n            }, {\n              name: 'terminal'\n            }, {\n              name: 'type'\n            }]\n          };\n        }\n      case EndOfFile:\n        {\n          return {\n            name: EndOfFile,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'lookahead'\n            }]\n          };\n        }\n      case Group:\n        {\n          return {\n            name: Group,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'elements',\n              defaultValue: []\n            }, {\n              name: 'guardCondition'\n            }, {\n              name: 'lookahead'\n            }]\n          };\n        }\n      case Keyword:\n        {\n          return {\n            name: Keyword,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'lookahead'\n            }, {\n              name: 'value'\n            }]\n          };\n        }\n      case NegatedToken:\n        {\n          return {\n            name: NegatedToken,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'lookahead'\n            }, {\n              name: 'terminal'\n            }]\n          };\n        }\n      case RegexToken:\n        {\n          return {\n            name: RegexToken,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'lookahead'\n            }, {\n              name: 'regex'\n            }]\n          };\n        }\n      case RuleCall:\n        {\n          return {\n            name: RuleCall,\n            properties: [{\n              name: 'arguments',\n              defaultValue: []\n            }, {\n              name: 'cardinality'\n            }, {\n              name: 'lookahead'\n            }, {\n              name: 'rule'\n            }]\n          };\n        }\n      case TerminalAlternatives:\n        {\n          return {\n            name: TerminalAlternatives,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'elements',\n              defaultValue: []\n            }, {\n              name: 'lookahead'\n            }]\n          };\n        }\n      case TerminalGroup:\n        {\n          return {\n            name: TerminalGroup,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'elements',\n              defaultValue: []\n            }, {\n              name: 'lookahead'\n            }]\n          };\n        }\n      case TerminalRuleCall:\n        {\n          return {\n            name: TerminalRuleCall,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'lookahead'\n            }, {\n              name: 'rule'\n            }]\n          };\n        }\n      case UnorderedGroup:\n        {\n          return {\n            name: UnorderedGroup,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'elements',\n              defaultValue: []\n            }, {\n              name: 'lookahead'\n            }]\n          };\n        }\n      case UntilToken:\n        {\n          return {\n            name: UntilToken,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'lookahead'\n            }, {\n              name: 'terminal'\n            }]\n          };\n        }\n      case Wildcard:\n        {\n          return {\n            name: Wildcard,\n            properties: [{\n              name: 'cardinality'\n            }, {\n              name: 'lookahead'\n            }]\n          };\n        }\n      default:\n        {\n          return {\n            name: type,\n            properties: []\n          };\n        }\n    }\n  }\n}\nexport const reflection = new LangiumGrammarAstReflection();","map":{"version":3,"names":["AbstractAstReflection","LangiumGrammarTerminals","ID","STRING","NUMBER","RegexLiteral","WS","ML_COMMENT","SL_COMMENT","AbstractRule","isAbstractRule","item","reflection","isInstance","AbstractType","isAbstractType","Condition","isCondition","isFeatureName","isPrimitiveType","test","TypeDefinition","isTypeDefinition","ValueLiteral","isValueLiteral","AbstractElement","isAbstractElement","ArrayLiteral","isArrayLiteral","ArrayType","isArrayType","BooleanLiteral","isBooleanLiteral","Conjunction","isConjunction","Disjunction","isDisjunction","Grammar","isGrammar","GrammarImport","isGrammarImport","InferredType","isInferredType","Interface","isInterface","NamedArgument","isNamedArgument","Negation","isNegation","NumberLiteral","isNumberLiteral","Parameter","isParameter","ParameterReference","isParameterReference","ParserRule","isParserRule","ReferenceType","isReferenceType","ReturnType","isReturnType","SimpleType","isSimpleType","StringLiteral","isStringLiteral","TerminalRule","isTerminalRule","Type","isType","TypeAttribute","isTypeAttribute","UnionType","isUnionType","Action","isAction","Alternatives","isAlternatives","Assignment","isAssignment","CharacterRange","isCharacterRange","CrossReference","isCrossReference","EndOfFile","isEndOfFile","Group","isGroup","Keyword","isKeyword","NegatedToken","isNegatedToken","RegexToken","isRegexToken","RuleCall","isRuleCall","TerminalAlternatives","isTerminalAlternatives","TerminalGroup","isTerminalGroup","TerminalRuleCall","isTerminalRuleCall","UnorderedGroup","isUnorderedGroup","UntilToken","isUntilToken","Wildcard","isWildcard","LangiumGrammarAstReflection","getAllTypes","computeIsSubtype","subtype","supertype","isSubtype","getReferenceType","refInfo","referenceId","container","$type","property","Error","getTypeMetaData","type","name","properties","defaultValue"],"sources":["D:\\DBMS\\DBMS Project\\frontend\\node_modules\\langium\\src\\languages\\generated\\ast.ts"],"sourcesContent":["/******************************************************************************\r\n * This file was generated by langium-cli 3.3.0.\r\n * DO NOT EDIT MANUALLY!\r\n ******************************************************************************/\r\n\r\n/* eslint-disable */\r\nimport type { AstNode, Reference, ReferenceInfo, TypeMetaData } from '../../syntax-tree.js';\r\nimport { AbstractAstReflection } from '../../syntax-tree.js';\r\n\r\nexport const LangiumGrammarTerminals = {\r\n    ID: /\\^?[_a-zA-Z][\\w_]*/,\r\n    STRING: /\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*'/,\r\n    NUMBER: /NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity)/,\r\n    RegexLiteral: /\\/(?![*+?])(?:[^\\r\\n\\[/\\\\]|\\\\.|\\[(?:[^\\r\\n\\]\\\\]|\\\\.)*\\])+\\/[a-z]*/,\r\n    WS: /\\s+/,\r\n    ML_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\r\n    SL_COMMENT: /\\/\\/[^\\n\\r]*/,\r\n};\r\n\r\nexport type LangiumGrammarTerminalNames = keyof typeof LangiumGrammarTerminals;\r\n\r\nexport type LangiumGrammarKeywordNames = \r\n    | \"!\"\r\n    | \"&\"\r\n    | \"(\"\r\n    | \")\"\r\n    | \"*\"\r\n    | \"+\"\r\n    | \"+=\"\r\n    | \",\"\r\n    | \"->\"\r\n    | \".\"\r\n    | \"..\"\r\n    | \":\"\r\n    | \";\"\r\n    | \"<\"\r\n    | \"=\"\r\n    | \"=>\"\r\n    | \">\"\r\n    | \"?\"\r\n    | \"?!\"\r\n    | \"?<!\"\r\n    | \"?<=\"\r\n    | \"?=\"\r\n    | \"@\"\r\n    | \"Date\"\r\n    | \"EOF\"\r\n    | \"[\"\r\n    | \"]\"\r\n    | \"bigint\"\r\n    | \"boolean\"\r\n    | \"current\"\r\n    | \"entry\"\r\n    | \"extends\"\r\n    | \"false\"\r\n    | \"fragment\"\r\n    | \"grammar\"\r\n    | \"hidden\"\r\n    | \"import\"\r\n    | \"infer\"\r\n    | \"infers\"\r\n    | \"interface\"\r\n    | \"number\"\r\n    | \"returns\"\r\n    | \"string\"\r\n    | \"terminal\"\r\n    | \"true\"\r\n    | \"type\"\r\n    | \"with\"\r\n    | \"{\"\r\n    | \"|\"\r\n    | \"}\";\r\n\r\nexport type LangiumGrammarTokenNames = LangiumGrammarTerminalNames | LangiumGrammarKeywordNames;\r\n\r\nexport type AbstractRule = ParserRule | TerminalRule;\r\n\r\nexport const AbstractRule = 'AbstractRule';\r\n\r\nexport function isAbstractRule(item: unknown): item is AbstractRule {\r\n    return reflection.isInstance(item, AbstractRule);\r\n}\r\n\r\nexport type AbstractType = InferredType | Interface | ParserRule | Type;\r\n\r\nexport const AbstractType = 'AbstractType';\r\n\r\nexport function isAbstractType(item: unknown): item is AbstractType {\r\n    return reflection.isInstance(item, AbstractType);\r\n}\r\n\r\nexport type Condition = BooleanLiteral | Conjunction | Disjunction | Negation | ParameterReference;\r\n\r\nexport const Condition = 'Condition';\r\n\r\nexport function isCondition(item: unknown): item is Condition {\r\n    return reflection.isInstance(item, Condition);\r\n}\r\n\r\nexport type FeatureName = 'current' | 'entry' | 'extends' | 'false' | 'fragment' | 'grammar' | 'hidden' | 'import' | 'infer' | 'infers' | 'interface' | 'returns' | 'terminal' | 'true' | 'type' | 'with' | PrimitiveType | string;\r\n\r\nexport function isFeatureName(item: unknown): item is FeatureName {\r\n    return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\\^?[_a-zA-Z][\\w_]*/.test(item)));\r\n}\r\n\r\nexport type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';\r\n\r\nexport function isPrimitiveType(item: unknown): item is PrimitiveType {\r\n    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';\r\n}\r\n\r\nexport type TypeDefinition = ArrayType | ReferenceType | SimpleType | UnionType;\r\n\r\nexport const TypeDefinition = 'TypeDefinition';\r\n\r\nexport function isTypeDefinition(item: unknown): item is TypeDefinition {\r\n    return reflection.isInstance(item, TypeDefinition);\r\n}\r\n\r\nexport type ValueLiteral = ArrayLiteral | BooleanLiteral | NumberLiteral | StringLiteral;\r\n\r\nexport const ValueLiteral = 'ValueLiteral';\r\n\r\nexport function isValueLiteral(item: unknown): item is ValueLiteral {\r\n    return reflection.isInstance(item, ValueLiteral);\r\n}\r\n\r\nexport interface AbstractElement extends AstNode {\r\n    readonly $type: 'AbstractElement' | 'Action' | 'Alternatives' | 'Assignment' | 'CharacterRange' | 'CrossReference' | 'EndOfFile' | 'Group' | 'Keyword' | 'NegatedToken' | 'RegexToken' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalGroup' | 'TerminalRuleCall' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';\r\n    cardinality?: '*' | '+' | '?';\r\n    lookahead?: '?!' | '?<!' | '?<=' | '?=';\r\n}\r\n\r\nexport const AbstractElement = 'AbstractElement';\r\n\r\nexport function isAbstractElement(item: unknown): item is AbstractElement {\r\n    return reflection.isInstance(item, AbstractElement);\r\n}\r\n\r\nexport interface ArrayLiteral extends AstNode {\r\n    readonly $container: ArrayLiteral | TypeAttribute;\r\n    readonly $type: 'ArrayLiteral';\r\n    elements: Array<ValueLiteral>;\r\n}\r\n\r\nexport const ArrayLiteral = 'ArrayLiteral';\r\n\r\nexport function isArrayLiteral(item: unknown): item is ArrayLiteral {\r\n    return reflection.isInstance(item, ArrayLiteral);\r\n}\r\n\r\nexport interface ArrayType extends AstNode {\r\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\r\n    readonly $type: 'ArrayType';\r\n    elementType: TypeDefinition;\r\n}\r\n\r\nexport const ArrayType = 'ArrayType';\r\n\r\nexport function isArrayType(item: unknown): item is ArrayType {\r\n    return reflection.isInstance(item, ArrayType);\r\n}\r\n\r\nexport interface BooleanLiteral extends AstNode {\r\n    readonly $container: ArrayLiteral | Conjunction | Disjunction | Group | NamedArgument | Negation | TypeAttribute;\r\n    readonly $type: 'BooleanLiteral';\r\n    true: boolean;\r\n}\r\n\r\nexport const BooleanLiteral = 'BooleanLiteral';\r\n\r\nexport function isBooleanLiteral(item: unknown): item is BooleanLiteral {\r\n    return reflection.isInstance(item, BooleanLiteral);\r\n}\r\n\r\nexport interface Conjunction extends AstNode {\r\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\r\n    readonly $type: 'Conjunction';\r\n    left: Condition;\r\n    right: Condition;\r\n}\r\n\r\nexport const Conjunction = 'Conjunction';\r\n\r\nexport function isConjunction(item: unknown): item is Conjunction {\r\n    return reflection.isInstance(item, Conjunction);\r\n}\r\n\r\nexport interface Disjunction extends AstNode {\r\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\r\n    readonly $type: 'Disjunction';\r\n    left: Condition;\r\n    right: Condition;\r\n}\r\n\r\nexport const Disjunction = 'Disjunction';\r\n\r\nexport function isDisjunction(item: unknown): item is Disjunction {\r\n    return reflection.isInstance(item, Disjunction);\r\n}\r\n\r\nexport interface Grammar extends AstNode {\r\n    readonly $type: 'Grammar';\r\n    definesHiddenTokens: boolean;\r\n    hiddenTokens: Array<Reference<AbstractRule>>;\r\n    imports: Array<GrammarImport>;\r\n    interfaces: Array<Interface>;\r\n    isDeclared: boolean;\r\n    name?: string;\r\n    rules: Array<AbstractRule>;\r\n    types: Array<Type>;\r\n    usedGrammars: Array<Reference<Grammar>>;\r\n}\r\n\r\nexport const Grammar = 'Grammar';\r\n\r\nexport function isGrammar(item: unknown): item is Grammar {\r\n    return reflection.isInstance(item, Grammar);\r\n}\r\n\r\nexport interface GrammarImport extends AstNode {\r\n    readonly $container: Grammar;\r\n    readonly $type: 'GrammarImport';\r\n    path: string;\r\n}\r\n\r\nexport const GrammarImport = 'GrammarImport';\r\n\r\nexport function isGrammarImport(item: unknown): item is GrammarImport {\r\n    return reflection.isInstance(item, GrammarImport);\r\n}\r\n\r\nexport interface InferredType extends AstNode {\r\n    readonly $container: Action | ParserRule;\r\n    readonly $type: 'InferredType';\r\n    name: string;\r\n}\r\n\r\nexport const InferredType = 'InferredType';\r\n\r\nexport function isInferredType(item: unknown): item is InferredType {\r\n    return reflection.isInstance(item, InferredType);\r\n}\r\n\r\nexport interface Interface extends AstNode {\r\n    readonly $container: Grammar;\r\n    readonly $type: 'Interface';\r\n    attributes: Array<TypeAttribute>;\r\n    name: string;\r\n    superTypes: Array<Reference<AbstractType>>;\r\n}\r\n\r\nexport const Interface = 'Interface';\r\n\r\nexport function isInterface(item: unknown): item is Interface {\r\n    return reflection.isInstance(item, Interface);\r\n}\r\n\r\nexport interface NamedArgument extends AstNode {\r\n    readonly $container: RuleCall;\r\n    readonly $type: 'NamedArgument';\r\n    calledByName: boolean;\r\n    parameter?: Reference<Parameter>;\r\n    value: Condition;\r\n}\r\n\r\nexport const NamedArgument = 'NamedArgument';\r\n\r\nexport function isNamedArgument(item: unknown): item is NamedArgument {\r\n    return reflection.isInstance(item, NamedArgument);\r\n}\r\n\r\nexport interface Negation extends AstNode {\r\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\r\n    readonly $type: 'Negation';\r\n    value: Condition;\r\n}\r\n\r\nexport const Negation = 'Negation';\r\n\r\nexport function isNegation(item: unknown): item is Negation {\r\n    return reflection.isInstance(item, Negation);\r\n}\r\n\r\nexport interface NumberLiteral extends AstNode {\r\n    readonly $container: ArrayLiteral | TypeAttribute;\r\n    readonly $type: 'NumberLiteral';\r\n    value: number;\r\n}\r\n\r\nexport const NumberLiteral = 'NumberLiteral';\r\n\r\nexport function isNumberLiteral(item: unknown): item is NumberLiteral {\r\n    return reflection.isInstance(item, NumberLiteral);\r\n}\r\n\r\nexport interface Parameter extends AstNode {\r\n    readonly $container: ParserRule;\r\n    readonly $type: 'Parameter';\r\n    name: string;\r\n}\r\n\r\nexport const Parameter = 'Parameter';\r\n\r\nexport function isParameter(item: unknown): item is Parameter {\r\n    return reflection.isInstance(item, Parameter);\r\n}\r\n\r\nexport interface ParameterReference extends AstNode {\r\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\r\n    readonly $type: 'ParameterReference';\r\n    parameter: Reference<Parameter>;\r\n}\r\n\r\nexport const ParameterReference = 'ParameterReference';\r\n\r\nexport function isParameterReference(item: unknown): item is ParameterReference {\r\n    return reflection.isInstance(item, ParameterReference);\r\n}\r\n\r\nexport interface ParserRule extends AstNode {\r\n    readonly $container: Grammar;\r\n    readonly $type: 'ParserRule';\r\n    dataType?: PrimitiveType;\r\n    definesHiddenTokens: boolean;\r\n    definition: AbstractElement;\r\n    entry: boolean;\r\n    fragment: boolean;\r\n    hiddenTokens: Array<Reference<AbstractRule>>;\r\n    inferredType?: InferredType;\r\n    name: string;\r\n    parameters: Array<Parameter>;\r\n    returnType?: Reference<AbstractType>;\r\n    wildcard: boolean;\r\n}\r\n\r\nexport const ParserRule = 'ParserRule';\r\n\r\nexport function isParserRule(item: unknown): item is ParserRule {\r\n    return reflection.isInstance(item, ParserRule);\r\n}\r\n\r\nexport interface ReferenceType extends AstNode {\r\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\r\n    readonly $type: 'ReferenceType';\r\n    referenceType: TypeDefinition;\r\n}\r\n\r\nexport const ReferenceType = 'ReferenceType';\r\n\r\nexport function isReferenceType(item: unknown): item is ReferenceType {\r\n    return reflection.isInstance(item, ReferenceType);\r\n}\r\n\r\nexport interface ReturnType extends AstNode {\r\n    readonly $container: TerminalRule;\r\n    readonly $type: 'ReturnType';\r\n    name: PrimitiveType | string;\r\n}\r\n\r\nexport const ReturnType = 'ReturnType';\r\n\r\nexport function isReturnType(item: unknown): item is ReturnType {\r\n    return reflection.isInstance(item, ReturnType);\r\n}\r\n\r\nexport interface SimpleType extends AstNode {\r\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\r\n    readonly $type: 'SimpleType';\r\n    primitiveType?: PrimitiveType;\r\n    stringType?: string;\r\n    typeRef?: Reference<AbstractType>;\r\n}\r\n\r\nexport const SimpleType = 'SimpleType';\r\n\r\nexport function isSimpleType(item: unknown): item is SimpleType {\r\n    return reflection.isInstance(item, SimpleType);\r\n}\r\n\r\nexport interface StringLiteral extends AstNode {\r\n    readonly $container: ArrayLiteral | TypeAttribute;\r\n    readonly $type: 'StringLiteral';\r\n    value: string;\r\n}\r\n\r\nexport const StringLiteral = 'StringLiteral';\r\n\r\nexport function isStringLiteral(item: unknown): item is StringLiteral {\r\n    return reflection.isInstance(item, StringLiteral);\r\n}\r\n\r\nexport interface TerminalRule extends AstNode {\r\n    readonly $container: Grammar;\r\n    readonly $type: 'TerminalRule';\r\n    definition: AbstractElement;\r\n    fragment: boolean;\r\n    hidden: boolean;\r\n    name: string;\r\n    type?: ReturnType;\r\n}\r\n\r\nexport const TerminalRule = 'TerminalRule';\r\n\r\nexport function isTerminalRule(item: unknown): item is TerminalRule {\r\n    return reflection.isInstance(item, TerminalRule);\r\n}\r\n\r\nexport interface Type extends AstNode {\r\n    readonly $container: Grammar;\r\n    readonly $type: 'Type';\r\n    name: string;\r\n    type: TypeDefinition;\r\n}\r\n\r\nexport const Type = 'Type';\r\n\r\nexport function isType(item: unknown): item is Type {\r\n    return reflection.isInstance(item, Type);\r\n}\r\n\r\nexport interface TypeAttribute extends AstNode {\r\n    readonly $container: Interface;\r\n    readonly $type: 'TypeAttribute';\r\n    defaultValue?: ValueLiteral;\r\n    isOptional: boolean;\r\n    name: FeatureName;\r\n    type: TypeDefinition;\r\n}\r\n\r\nexport const TypeAttribute = 'TypeAttribute';\r\n\r\nexport function isTypeAttribute(item: unknown): item is TypeAttribute {\r\n    return reflection.isInstance(item, TypeAttribute);\r\n}\r\n\r\nexport interface UnionType extends AstNode {\r\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\r\n    readonly $type: 'UnionType';\r\n    types: Array<TypeDefinition>;\r\n}\r\n\r\nexport const UnionType = 'UnionType';\r\n\r\nexport function isUnionType(item: unknown): item is UnionType {\r\n    return reflection.isInstance(item, UnionType);\r\n}\r\n\r\nexport interface Action extends AbstractElement {\r\n    readonly $type: 'Action';\r\n    feature?: FeatureName;\r\n    inferredType?: InferredType;\r\n    operator?: '+=' | '=';\r\n    type?: Reference<AbstractType>;\r\n}\r\n\r\nexport const Action = 'Action';\r\n\r\nexport function isAction(item: unknown): item is Action {\r\n    return reflection.isInstance(item, Action);\r\n}\r\n\r\nexport interface Alternatives extends AbstractElement {\r\n    readonly $type: 'Alternatives';\r\n    elements: Array<AbstractElement>;\r\n}\r\n\r\nexport const Alternatives = 'Alternatives';\r\n\r\nexport function isAlternatives(item: unknown): item is Alternatives {\r\n    return reflection.isInstance(item, Alternatives);\r\n}\r\n\r\nexport interface Assignment extends AbstractElement {\r\n    readonly $type: 'Assignment';\r\n    feature: FeatureName;\r\n    operator: '+=' | '=' | '?=';\r\n    terminal: AbstractElement;\r\n}\r\n\r\nexport const Assignment = 'Assignment';\r\n\r\nexport function isAssignment(item: unknown): item is Assignment {\r\n    return reflection.isInstance(item, Assignment);\r\n}\r\n\r\nexport interface CharacterRange extends AbstractElement {\r\n    readonly $type: 'CharacterRange';\r\n    left: Keyword;\r\n    right?: Keyword;\r\n}\r\n\r\nexport const CharacterRange = 'CharacterRange';\r\n\r\nexport function isCharacterRange(item: unknown): item is CharacterRange {\r\n    return reflection.isInstance(item, CharacterRange);\r\n}\r\n\r\nexport interface CrossReference extends AbstractElement {\r\n    readonly $type: 'CrossReference';\r\n    deprecatedSyntax: boolean;\r\n    terminal?: AbstractElement;\r\n    type: Reference<AbstractType>;\r\n}\r\n\r\nexport const CrossReference = 'CrossReference';\r\n\r\nexport function isCrossReference(item: unknown): item is CrossReference {\r\n    return reflection.isInstance(item, CrossReference);\r\n}\r\n\r\nexport interface EndOfFile extends AbstractElement {\r\n    readonly $type: 'EndOfFile';\r\n}\r\n\r\nexport const EndOfFile = 'EndOfFile';\r\n\r\nexport function isEndOfFile(item: unknown): item is EndOfFile {\r\n    return reflection.isInstance(item, EndOfFile);\r\n}\r\n\r\nexport interface Group extends AbstractElement {\r\n    readonly $type: 'Group';\r\n    elements: Array<AbstractElement>;\r\n    guardCondition?: Condition;\r\n}\r\n\r\nexport const Group = 'Group';\r\n\r\nexport function isGroup(item: unknown): item is Group {\r\n    return reflection.isInstance(item, Group);\r\n}\r\n\r\nexport interface Keyword extends AbstractElement {\r\n    readonly $container: CharacterRange;\r\n    readonly $type: 'Keyword';\r\n    value: string;\r\n}\r\n\r\nexport const Keyword = 'Keyword';\r\n\r\nexport function isKeyword(item: unknown): item is Keyword {\r\n    return reflection.isInstance(item, Keyword);\r\n}\r\n\r\nexport interface NegatedToken extends AbstractElement {\r\n    readonly $type: 'NegatedToken';\r\n    terminal: AbstractElement;\r\n}\r\n\r\nexport const NegatedToken = 'NegatedToken';\r\n\r\nexport function isNegatedToken(item: unknown): item is NegatedToken {\r\n    return reflection.isInstance(item, NegatedToken);\r\n}\r\n\r\nexport interface RegexToken extends AbstractElement {\r\n    readonly $type: 'RegexToken';\r\n    regex: string;\r\n}\r\n\r\nexport const RegexToken = 'RegexToken';\r\n\r\nexport function isRegexToken(item: unknown): item is RegexToken {\r\n    return reflection.isInstance(item, RegexToken);\r\n}\r\n\r\nexport interface RuleCall extends AbstractElement {\r\n    readonly $type: 'RuleCall';\r\n    arguments: Array<NamedArgument>;\r\n    rule: Reference<AbstractRule>;\r\n}\r\n\r\nexport const RuleCall = 'RuleCall';\r\n\r\nexport function isRuleCall(item: unknown): item is RuleCall {\r\n    return reflection.isInstance(item, RuleCall);\r\n}\r\n\r\nexport interface TerminalAlternatives extends AbstractElement {\r\n    readonly $type: 'TerminalAlternatives';\r\n    elements: Array<AbstractElement>;\r\n}\r\n\r\nexport const TerminalAlternatives = 'TerminalAlternatives';\r\n\r\nexport function isTerminalAlternatives(item: unknown): item is TerminalAlternatives {\r\n    return reflection.isInstance(item, TerminalAlternatives);\r\n}\r\n\r\nexport interface TerminalGroup extends AbstractElement {\r\n    readonly $type: 'TerminalGroup';\r\n    elements: Array<AbstractElement>;\r\n}\r\n\r\nexport const TerminalGroup = 'TerminalGroup';\r\n\r\nexport function isTerminalGroup(item: unknown): item is TerminalGroup {\r\n    return reflection.isInstance(item, TerminalGroup);\r\n}\r\n\r\nexport interface TerminalRuleCall extends AbstractElement {\r\n    readonly $type: 'TerminalRuleCall';\r\n    rule: Reference<TerminalRule>;\r\n}\r\n\r\nexport const TerminalRuleCall = 'TerminalRuleCall';\r\n\r\nexport function isTerminalRuleCall(item: unknown): item is TerminalRuleCall {\r\n    return reflection.isInstance(item, TerminalRuleCall);\r\n}\r\n\r\nexport interface UnorderedGroup extends AbstractElement {\r\n    readonly $type: 'UnorderedGroup';\r\n    elements: Array<AbstractElement>;\r\n}\r\n\r\nexport const UnorderedGroup = 'UnorderedGroup';\r\n\r\nexport function isUnorderedGroup(item: unknown): item is UnorderedGroup {\r\n    return reflection.isInstance(item, UnorderedGroup);\r\n}\r\n\r\nexport interface UntilToken extends AbstractElement {\r\n    readonly $type: 'UntilToken';\r\n    terminal: AbstractElement;\r\n}\r\n\r\nexport const UntilToken = 'UntilToken';\r\n\r\nexport function isUntilToken(item: unknown): item is UntilToken {\r\n    return reflection.isInstance(item, UntilToken);\r\n}\r\n\r\nexport interface Wildcard extends AbstractElement {\r\n    readonly $type: 'Wildcard';\r\n}\r\n\r\nexport const Wildcard = 'Wildcard';\r\n\r\nexport function isWildcard(item: unknown): item is Wildcard {\r\n    return reflection.isInstance(item, Wildcard);\r\n}\r\n\r\nexport type LangiumGrammarAstType = {\r\n    AbstractElement: AbstractElement\r\n    AbstractRule: AbstractRule\r\n    AbstractType: AbstractType\r\n    Action: Action\r\n    Alternatives: Alternatives\r\n    ArrayLiteral: ArrayLiteral\r\n    ArrayType: ArrayType\r\n    Assignment: Assignment\r\n    BooleanLiteral: BooleanLiteral\r\n    CharacterRange: CharacterRange\r\n    Condition: Condition\r\n    Conjunction: Conjunction\r\n    CrossReference: CrossReference\r\n    Disjunction: Disjunction\r\n    EndOfFile: EndOfFile\r\n    Grammar: Grammar\r\n    GrammarImport: GrammarImport\r\n    Group: Group\r\n    InferredType: InferredType\r\n    Interface: Interface\r\n    Keyword: Keyword\r\n    NamedArgument: NamedArgument\r\n    NegatedToken: NegatedToken\r\n    Negation: Negation\r\n    NumberLiteral: NumberLiteral\r\n    Parameter: Parameter\r\n    ParameterReference: ParameterReference\r\n    ParserRule: ParserRule\r\n    ReferenceType: ReferenceType\r\n    RegexToken: RegexToken\r\n    ReturnType: ReturnType\r\n    RuleCall: RuleCall\r\n    SimpleType: SimpleType\r\n    StringLiteral: StringLiteral\r\n    TerminalAlternatives: TerminalAlternatives\r\n    TerminalGroup: TerminalGroup\r\n    TerminalRule: TerminalRule\r\n    TerminalRuleCall: TerminalRuleCall\r\n    Type: Type\r\n    TypeAttribute: TypeAttribute\r\n    TypeDefinition: TypeDefinition\r\n    UnionType: UnionType\r\n    UnorderedGroup: UnorderedGroup\r\n    UntilToken: UntilToken\r\n    ValueLiteral: ValueLiteral\r\n    Wildcard: Wildcard\r\n}\r\n\r\nexport class LangiumGrammarAstReflection extends AbstractAstReflection {\r\n\r\n    getAllTypes(): string[] {\r\n        return [AbstractElement, AbstractRule, AbstractType, Action, Alternatives, ArrayLiteral, ArrayType, Assignment, BooleanLiteral, CharacterRange, Condition, Conjunction, CrossReference, Disjunction, EndOfFile, Grammar, GrammarImport, Group, InferredType, Interface, Keyword, NamedArgument, NegatedToken, Negation, NumberLiteral, Parameter, ParameterReference, ParserRule, ReferenceType, RegexToken, ReturnType, RuleCall, SimpleType, StringLiteral, TerminalAlternatives, TerminalGroup, TerminalRule, TerminalRuleCall, Type, TypeAttribute, TypeDefinition, UnionType, UnorderedGroup, UntilToken, ValueLiteral, Wildcard];\r\n    }\r\n\r\n    protected override computeIsSubtype(subtype: string, supertype: string): boolean {\r\n        switch (subtype) {\r\n            case Action:\r\n            case Alternatives:\r\n            case Assignment:\r\n            case CharacterRange:\r\n            case CrossReference:\r\n            case EndOfFile:\r\n            case Group:\r\n            case Keyword:\r\n            case NegatedToken:\r\n            case RegexToken:\r\n            case RuleCall:\r\n            case TerminalAlternatives:\r\n            case TerminalGroup:\r\n            case TerminalRuleCall:\r\n            case UnorderedGroup:\r\n            case UntilToken:\r\n            case Wildcard: {\r\n                return this.isSubtype(AbstractElement, supertype);\r\n            }\r\n            case ArrayLiteral:\r\n            case NumberLiteral:\r\n            case StringLiteral: {\r\n                return this.isSubtype(ValueLiteral, supertype);\r\n            }\r\n            case ArrayType:\r\n            case ReferenceType:\r\n            case SimpleType:\r\n            case UnionType: {\r\n                return this.isSubtype(TypeDefinition, supertype);\r\n            }\r\n            case BooleanLiteral: {\r\n                return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);\r\n            }\r\n            case Conjunction:\r\n            case Disjunction:\r\n            case Negation:\r\n            case ParameterReference: {\r\n                return this.isSubtype(Condition, supertype);\r\n            }\r\n            case InferredType:\r\n            case Interface:\r\n            case Type: {\r\n                return this.isSubtype(AbstractType, supertype);\r\n            }\r\n            case ParserRule: {\r\n                return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);\r\n            }\r\n            case TerminalRule: {\r\n                return this.isSubtype(AbstractRule, supertype);\r\n            }\r\n            default: {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    getReferenceType(refInfo: ReferenceInfo): string {\r\n        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\r\n        switch (referenceId) {\r\n            case 'Action:type':\r\n            case 'CrossReference:type':\r\n            case 'Interface:superTypes':\r\n            case 'ParserRule:returnType':\r\n            case 'SimpleType:typeRef': {\r\n                return AbstractType;\r\n            }\r\n            case 'Grammar:hiddenTokens':\r\n            case 'ParserRule:hiddenTokens':\r\n            case 'RuleCall:rule': {\r\n                return AbstractRule;\r\n            }\r\n            case 'Grammar:usedGrammars': {\r\n                return Grammar;\r\n            }\r\n            case 'NamedArgument:parameter':\r\n            case 'ParameterReference:parameter': {\r\n                return Parameter;\r\n            }\r\n            case 'TerminalRuleCall:rule': {\r\n                return TerminalRule;\r\n            }\r\n            default: {\r\n                throw new Error(`${referenceId} is not a valid reference id.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    getTypeMetaData(type: string): TypeMetaData {\r\n        switch (type) {\r\n            case AbstractElement: {\r\n                return {\r\n                    name: AbstractElement,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            case ArrayLiteral: {\r\n                return {\r\n                    name: ArrayLiteral,\r\n                    properties: [\r\n                        { name: 'elements', defaultValue: [] }\r\n                    ]\r\n                };\r\n            }\r\n            case ArrayType: {\r\n                return {\r\n                    name: ArrayType,\r\n                    properties: [\r\n                        { name: 'elementType' }\r\n                    ]\r\n                };\r\n            }\r\n            case BooleanLiteral: {\r\n                return {\r\n                    name: BooleanLiteral,\r\n                    properties: [\r\n                        { name: 'true', defaultValue: false }\r\n                    ]\r\n                };\r\n            }\r\n            case Conjunction: {\r\n                return {\r\n                    name: Conjunction,\r\n                    properties: [\r\n                        { name: 'left' },\r\n                        { name: 'right' }\r\n                    ]\r\n                };\r\n            }\r\n            case Disjunction: {\r\n                return {\r\n                    name: Disjunction,\r\n                    properties: [\r\n                        { name: 'left' },\r\n                        { name: 'right' }\r\n                    ]\r\n                };\r\n            }\r\n            case Grammar: {\r\n                return {\r\n                    name: Grammar,\r\n                    properties: [\r\n                        { name: 'definesHiddenTokens', defaultValue: false },\r\n                        { name: 'hiddenTokens', defaultValue: [] },\r\n                        { name: 'imports', defaultValue: [] },\r\n                        { name: 'interfaces', defaultValue: [] },\r\n                        { name: 'isDeclared', defaultValue: false },\r\n                        { name: 'name' },\r\n                        { name: 'rules', defaultValue: [] },\r\n                        { name: 'types', defaultValue: [] },\r\n                        { name: 'usedGrammars', defaultValue: [] }\r\n                    ]\r\n                };\r\n            }\r\n            case GrammarImport: {\r\n                return {\r\n                    name: GrammarImport,\r\n                    properties: [\r\n                        { name: 'path' }\r\n                    ]\r\n                };\r\n            }\r\n            case InferredType: {\r\n                return {\r\n                    name: InferredType,\r\n                    properties: [\r\n                        { name: 'name' }\r\n                    ]\r\n                };\r\n            }\r\n            case Interface: {\r\n                return {\r\n                    name: Interface,\r\n                    properties: [\r\n                        { name: 'attributes', defaultValue: [] },\r\n                        { name: 'name' },\r\n                        { name: 'superTypes', defaultValue: [] }\r\n                    ]\r\n                };\r\n            }\r\n            case NamedArgument: {\r\n                return {\r\n                    name: NamedArgument,\r\n                    properties: [\r\n                        { name: 'calledByName', defaultValue: false },\r\n                        { name: 'parameter' },\r\n                        { name: 'value' }\r\n                    ]\r\n                };\r\n            }\r\n            case Negation: {\r\n                return {\r\n                    name: Negation,\r\n                    properties: [\r\n                        { name: 'value' }\r\n                    ]\r\n                };\r\n            }\r\n            case NumberLiteral: {\r\n                return {\r\n                    name: NumberLiteral,\r\n                    properties: [\r\n                        { name: 'value' }\r\n                    ]\r\n                };\r\n            }\r\n            case Parameter: {\r\n                return {\r\n                    name: Parameter,\r\n                    properties: [\r\n                        { name: 'name' }\r\n                    ]\r\n                };\r\n            }\r\n            case ParameterReference: {\r\n                return {\r\n                    name: ParameterReference,\r\n                    properties: [\r\n                        { name: 'parameter' }\r\n                    ]\r\n                };\r\n            }\r\n            case ParserRule: {\r\n                return {\r\n                    name: ParserRule,\r\n                    properties: [\r\n                        { name: 'dataType' },\r\n                        { name: 'definesHiddenTokens', defaultValue: false },\r\n                        { name: 'definition' },\r\n                        { name: 'entry', defaultValue: false },\r\n                        { name: 'fragment', defaultValue: false },\r\n                        { name: 'hiddenTokens', defaultValue: [] },\r\n                        { name: 'inferredType' },\r\n                        { name: 'name' },\r\n                        { name: 'parameters', defaultValue: [] },\r\n                        { name: 'returnType' },\r\n                        { name: 'wildcard', defaultValue: false }\r\n                    ]\r\n                };\r\n            }\r\n            case ReferenceType: {\r\n                return {\r\n                    name: ReferenceType,\r\n                    properties: [\r\n                        { name: 'referenceType' }\r\n                    ]\r\n                };\r\n            }\r\n            case ReturnType: {\r\n                return {\r\n                    name: ReturnType,\r\n                    properties: [\r\n                        { name: 'name' }\r\n                    ]\r\n                };\r\n            }\r\n            case SimpleType: {\r\n                return {\r\n                    name: SimpleType,\r\n                    properties: [\r\n                        { name: 'primitiveType' },\r\n                        { name: 'stringType' },\r\n                        { name: 'typeRef' }\r\n                    ]\r\n                };\r\n            }\r\n            case StringLiteral: {\r\n                return {\r\n                    name: StringLiteral,\r\n                    properties: [\r\n                        { name: 'value' }\r\n                    ]\r\n                };\r\n            }\r\n            case TerminalRule: {\r\n                return {\r\n                    name: TerminalRule,\r\n                    properties: [\r\n                        { name: 'definition' },\r\n                        { name: 'fragment', defaultValue: false },\r\n                        { name: 'hidden', defaultValue: false },\r\n                        { name: 'name' },\r\n                        { name: 'type' }\r\n                    ]\r\n                };\r\n            }\r\n            case Type: {\r\n                return {\r\n                    name: Type,\r\n                    properties: [\r\n                        { name: 'name' },\r\n                        { name: 'type' }\r\n                    ]\r\n                };\r\n            }\r\n            case TypeAttribute: {\r\n                return {\r\n                    name: TypeAttribute,\r\n                    properties: [\r\n                        { name: 'defaultValue' },\r\n                        { name: 'isOptional', defaultValue: false },\r\n                        { name: 'name' },\r\n                        { name: 'type' }\r\n                    ]\r\n                };\r\n            }\r\n            case UnionType: {\r\n                return {\r\n                    name: UnionType,\r\n                    properties: [\r\n                        { name: 'types', defaultValue: [] }\r\n                    ]\r\n                };\r\n            }\r\n            case Action: {\r\n                return {\r\n                    name: Action,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'feature' },\r\n                        { name: 'inferredType' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'operator' },\r\n                        { name: 'type' }\r\n                    ]\r\n                };\r\n            }\r\n            case Alternatives: {\r\n                return {\r\n                    name: Alternatives,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'elements', defaultValue: [] },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            case Assignment: {\r\n                return {\r\n                    name: Assignment,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'feature' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'operator' },\r\n                        { name: 'terminal' }\r\n                    ]\r\n                };\r\n            }\r\n            case CharacterRange: {\r\n                return {\r\n                    name: CharacterRange,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'left' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'right' }\r\n                    ]\r\n                };\r\n            }\r\n            case CrossReference: {\r\n                return {\r\n                    name: CrossReference,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'deprecatedSyntax', defaultValue: false },\r\n                        { name: 'lookahead' },\r\n                        { name: 'terminal' },\r\n                        { name: 'type' }\r\n                    ]\r\n                };\r\n            }\r\n            case EndOfFile: {\r\n                return {\r\n                    name: EndOfFile,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            case Group: {\r\n                return {\r\n                    name: Group,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'elements', defaultValue: [] },\r\n                        { name: 'guardCondition' },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            case Keyword: {\r\n                return {\r\n                    name: Keyword,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'value' }\r\n                    ]\r\n                };\r\n            }\r\n            case NegatedToken: {\r\n                return {\r\n                    name: NegatedToken,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'terminal' }\r\n                    ]\r\n                };\r\n            }\r\n            case RegexToken: {\r\n                return {\r\n                    name: RegexToken,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'regex' }\r\n                    ]\r\n                };\r\n            }\r\n            case RuleCall: {\r\n                return {\r\n                    name: RuleCall,\r\n                    properties: [\r\n                        { name: 'arguments', defaultValue: [] },\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'rule' }\r\n                    ]\r\n                };\r\n            }\r\n            case TerminalAlternatives: {\r\n                return {\r\n                    name: TerminalAlternatives,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'elements', defaultValue: [] },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            case TerminalGroup: {\r\n                return {\r\n                    name: TerminalGroup,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'elements', defaultValue: [] },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            case TerminalRuleCall: {\r\n                return {\r\n                    name: TerminalRuleCall,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'rule' }\r\n                    ]\r\n                };\r\n            }\r\n            case UnorderedGroup: {\r\n                return {\r\n                    name: UnorderedGroup,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'elements', defaultValue: [] },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            case UntilToken: {\r\n                return {\r\n                    name: UntilToken,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' },\r\n                        { name: 'terminal' }\r\n                    ]\r\n                };\r\n            }\r\n            case Wildcard: {\r\n                return {\r\n                    name: Wildcard,\r\n                    properties: [\r\n                        { name: 'cardinality' },\r\n                        { name: 'lookahead' }\r\n                    ]\r\n                };\r\n            }\r\n            default: {\r\n                return {\r\n                    name: type,\r\n                    properties: []\r\n                };\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const reflection = new LangiumGrammarAstReflection();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}