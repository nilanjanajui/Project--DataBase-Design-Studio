{"ast":null,"code":"/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { UriUtils } from './utils/uri-utils.js';\n/**\n * Generic registry for Langium services, but capable of being used with extending service sets as well (such as the lsp-complete LangiumCoreServices set)\n */\nexport class DefaultServiceRegistry {\n  /**\n   * @deprecated Use the new `fileExtensionMap` (or `languageIdMap`) property instead.\n   */\n  get map() {\n    return this.fileExtensionMap;\n  }\n  constructor(services) {\n    this.languageIdMap = new Map();\n    this.fileExtensionMap = new Map();\n    this.textDocuments = services === null || services === void 0 ? void 0 : services.workspace.TextDocuments;\n  }\n  register(language) {\n    const data = language.LanguageMetaData;\n    for (const ext of data.fileExtensions) {\n      if (this.fileExtensionMap.has(ext)) {\n        console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${data.languageId}'.`);\n      }\n      this.fileExtensionMap.set(ext, language);\n    }\n    this.languageIdMap.set(data.languageId, language);\n    if (this.languageIdMap.size === 1) {\n      this.singleton = language;\n    } else {\n      this.singleton = undefined;\n    }\n  }\n  getServices(uri) {\n    var _a, _b;\n    if (this.singleton !== undefined) {\n      return this.singleton;\n    }\n    if (this.languageIdMap.size === 0) {\n      throw new Error('The service registry is empty. Use `register` to register the services of a language.');\n    }\n    const languageId = (_b = (_a = this.textDocuments) === null || _a === void 0 ? void 0 : _a.get(uri)) === null || _b === void 0 ? void 0 : _b.languageId;\n    if (languageId !== undefined) {\n      const services = this.languageIdMap.get(languageId);\n      if (services) {\n        return services;\n      }\n    }\n    const ext = UriUtils.extname(uri);\n    const services = this.fileExtensionMap.get(ext);\n    if (!services) {\n      if (languageId) {\n        throw new Error(`The service registry contains no services for the extension '${ext}' for language '${languageId}'.`);\n      } else {\n        throw new Error(`The service registry contains no services for the extension '${ext}'.`);\n      }\n    }\n    return services;\n  }\n  hasServices(uri) {\n    try {\n      this.getServices(uri);\n      return true;\n    } catch (_a) {\n      return false;\n    }\n  }\n  get all() {\n    return Array.from(this.languageIdMap.values());\n  }\n}","map":{"version":3,"names":["UriUtils","DefaultServiceRegistry","map","fileExtensionMap","constructor","services","languageIdMap","Map","textDocuments","workspace","TextDocuments","register","language","data","LanguageMetaData","ext","fileExtensions","has","console","warn","languageId","set","size","singleton","undefined","getServices","uri","Error","_b","_a","get","extname","hasServices","all","Array","from","values"],"sources":["D:\\DBMS\\DBMS Project\\frontend\\node_modules\\langium\\src\\service-registry.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumCoreServices, LangiumSharedCoreServices } from './services.js';\r\nimport type { TextDocumentProvider } from './workspace/documents.js';\r\nimport { UriUtils, type URI } from './utils/uri-utils.js';\r\n\r\n/**\r\n * The service registry provides access to the language-specific {@link LangiumCoreServices} optionally including LSP-related services.\r\n * These are resolved via the URI of a text document.\r\n */\r\nexport interface ServiceRegistry {\r\n\r\n    /**\r\n     * Register a language via its injected services.\r\n     */\r\n    register(language: LangiumCoreServices): void;\r\n\r\n    /**\r\n     * Retrieve the language-specific services for the given URI. In case only one language is\r\n     * registered, it may be used regardless of the URI format.\r\n     */\r\n    getServices(uri: URI): LangiumCoreServices;\r\n\r\n    /**\r\n     * Check whether services are available for the given URI.\r\n     */\r\n    hasServices(uri: URI): boolean;\r\n\r\n    /**\r\n     * The full set of registered language services.\r\n     */\r\n    readonly all: readonly LangiumCoreServices[];\r\n}\r\n\r\n/**\r\n * Generic registry for Langium services, but capable of being used with extending service sets as well (such as the lsp-complete LangiumCoreServices set)\r\n */\r\nexport class DefaultServiceRegistry implements ServiceRegistry {\r\n\r\n    protected singleton?: LangiumCoreServices;\r\n    protected readonly languageIdMap = new Map<string, LangiumCoreServices>();\r\n    protected readonly fileExtensionMap = new Map<string, LangiumCoreServices>();\r\n\r\n    /**\r\n     * @deprecated Use the new `fileExtensionMap` (or `languageIdMap`) property instead.\r\n     */\r\n    protected get map(): Map<string, LangiumCoreServices> | undefined {\r\n        return this.fileExtensionMap;\r\n    }\r\n\r\n    protected readonly textDocuments?: TextDocumentProvider;\r\n\r\n    constructor(services?: LangiumSharedCoreServices) {\r\n        this.textDocuments = services?.workspace.TextDocuments;\r\n    }\r\n\r\n    register(language: LangiumCoreServices): void {\r\n        const data = language.LanguageMetaData;\r\n        for (const ext of data.fileExtensions) {\r\n            if (this.fileExtensionMap.has(ext)) {\r\n                console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${data.languageId}'.`);\r\n            }\r\n            this.fileExtensionMap.set(ext, language);\r\n        }\r\n        this.languageIdMap.set(data.languageId, language);\r\n        if (this.languageIdMap.size === 1) {\r\n            this.singleton = language;\r\n        } else {\r\n            this.singleton = undefined;\r\n        }\r\n    }\r\n\r\n    getServices(uri: URI): LangiumCoreServices {\r\n        if (this.singleton !== undefined) {\r\n            return this.singleton;\r\n        }\r\n        if (this.languageIdMap.size === 0) {\r\n            throw new Error('The service registry is empty. Use `register` to register the services of a language.');\r\n        }\r\n        const languageId = this.textDocuments?.get(uri)?.languageId;\r\n        if (languageId !== undefined) {\r\n            const services = this.languageIdMap.get(languageId);\r\n            if (services) {\r\n                return services;\r\n            }\r\n        }\r\n        const ext = UriUtils.extname(uri);\r\n        const services = this.fileExtensionMap.get(ext);\r\n        if (!services) {\r\n            if (languageId) {\r\n                throw new Error(`The service registry contains no services for the extension '${ext}' for language '${languageId}'.`);\r\n            } else {\r\n                throw new Error(`The service registry contains no services for the extension '${ext}'.`);\r\n            }\r\n        }\r\n        return services;\r\n    }\r\n\r\n    hasServices(uri: URI): boolean {\r\n        try {\r\n            this.getServices(uri);\r\n            return true;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    get all(): readonly LangiumCoreServices[] {\r\n        return Array.from(this.languageIdMap.values());\r\n    }\r\n}\r\n"],"mappings":"AAAA;;;;;AAQA,SAASA,QAAQ,QAAkB,sBAAsB;AA8BzD;;;AAGA,OAAM,MAAOC,sBAAsB;EAM/B;;;EAGA,IAAcC,GAAGA,CAAA;IACb,OAAO,IAAI,CAACC,gBAAgB;EAChC;EAIAC,YAAYC,QAAoC;IAZ7B,KAAAC,aAAa,GAAG,IAAIC,GAAG,EAA+B;IACtD,KAAAJ,gBAAgB,GAAG,IAAII,GAAG,EAA+B;IAYxE,IAAI,CAACC,aAAa,GAAGH,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,CAAEI,SAAS,CAACC,aAAa;EAC1D;EAEAC,QAAQA,CAACC,QAA6B;IAClC,MAAMC,IAAI,GAAGD,QAAQ,CAACE,gBAAgB;IACtC,KAAK,MAAMC,GAAG,IAAIF,IAAI,CAACG,cAAc,EAAE;MACnC,IAAI,IAAI,CAACb,gBAAgB,CAACc,GAAG,CAACF,GAAG,CAAC,EAAE;QAChCG,OAAO,CAACC,IAAI,CAAC,sBAAsBJ,GAAG,0DAA0DF,IAAI,CAACO,UAAU,IAAI,CAAC;MACxH;MACA,IAAI,CAACjB,gBAAgB,CAACkB,GAAG,CAACN,GAAG,EAAEH,QAAQ,CAAC;IAC5C;IACA,IAAI,CAACN,aAAa,CAACe,GAAG,CAACR,IAAI,CAACO,UAAU,EAAER,QAAQ,CAAC;IACjD,IAAI,IAAI,CAACN,aAAa,CAACgB,IAAI,KAAK,CAAC,EAAE;MAC/B,IAAI,CAACC,SAAS,GAAGX,QAAQ;IAC7B,CAAC,MAAM;MACH,IAAI,CAACW,SAAS,GAAGC,SAAS;IAC9B;EACJ;EAEAC,WAAWA,CAACC,GAAQ;;IAChB,IAAI,IAAI,CAACH,SAAS,KAAKC,SAAS,EAAE;MAC9B,OAAO,IAAI,CAACD,SAAS;IACzB;IACA,IAAI,IAAI,CAACjB,aAAa,CAACgB,IAAI,KAAK,CAAC,EAAE;MAC/B,MAAM,IAAIK,KAAK,CAAC,uFAAuF,CAAC;IAC5G;IACA,MAAMP,UAAU,GAAG,CAAAQ,EAAA,IAAAC,EAAA,OAAI,CAACrB,aAAa,cAAAqB,EAAA,uBAAAA,EAAA,CAAEC,GAAG,CAACJ,GAAG,CAAC,cAAAE,EAAA,uBAAAA,EAAA,CAAER,UAAU;IAC3D,IAAIA,UAAU,KAAKI,SAAS,EAAE;MAC1B,MAAMnB,QAAQ,GAAG,IAAI,CAACC,aAAa,CAACwB,GAAG,CAACV,UAAU,CAAC;MACnD,IAAIf,QAAQ,EAAE;QACV,OAAOA,QAAQ;MACnB;IACJ;IACA,MAAMU,GAAG,GAAGf,QAAQ,CAAC+B,OAAO,CAACL,GAAG,CAAC;IACjC,MAAMrB,QAAQ,GAAG,IAAI,CAACF,gBAAgB,CAAC2B,GAAG,CAACf,GAAG,CAAC;IAC/C,IAAI,CAACV,QAAQ,EAAE;MACX,IAAIe,UAAU,EAAE;QACZ,MAAM,IAAIO,KAAK,CAAC,gEAAgEZ,GAAG,mBAAmBK,UAAU,IAAI,CAAC;MACzH,CAAC,MAAM;QACH,MAAM,IAAIO,KAAK,CAAC,gEAAgEZ,GAAG,IAAI,CAAC;MAC5F;IACJ;IACA,OAAOV,QAAQ;EACnB;EAEA2B,WAAWA,CAACN,GAAQ;IAChB,IAAI;MACA,IAAI,CAACD,WAAW,CAACC,GAAG,CAAC;MACrB,OAAO,IAAI;IACf,CAAC,CAAC,OAAAG,EAAA,EAAM;MACJ,OAAO,KAAK;IAChB;EACJ;EAEA,IAAII,GAAGA,CAAA;IACH,OAAOC,KAAK,CAACC,IAAI,CAAC,IAAI,CAAC7B,aAAa,CAAC8B,MAAM,EAAE,CAAC;EAClD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}