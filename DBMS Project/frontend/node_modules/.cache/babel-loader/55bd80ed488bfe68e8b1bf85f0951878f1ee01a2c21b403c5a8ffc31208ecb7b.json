{"ast":null,"code":"import { decodeEntities } from \"./chunk-55PJQP7W.mjs\";\nimport { __name, common_default, getConfig2 as getConfig, hasKatex, log, renderKatex, sanitizeText2 as sanitizeText } from \"./chunk-3XYRH5AP.mjs\";\n\n// src/rendering-util/icons.ts\nimport { getIconData, iconToHTML, iconToSVG, replaceIDs, stringToIcon } from \"@iconify/utils\";\nvar unknownIcon = {\n  body: '<g><rect width=\"80\" height=\"80\" style=\"fill: #087ebf; stroke-width: 0px;\"/><text transform=\"translate(21.16 64.67)\" style=\"fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;\"><tspan x=\"0\" y=\"0\">?</tspan></text></g>',\n  height: 80,\n  width: 80\n};\nvar iconsStore = /* @__PURE__ */new Map();\nvar loaderStore = /* @__PURE__ */new Map();\nvar registerIconPacks = /* @__PURE__ */__name(iconLoaders => {\n  for (const iconLoader of iconLoaders) {\n    if (!iconLoader.name) {\n      throw new Error('Invalid icon loader. Must have a \"name\" property with non-empty string value.');\n    }\n    log.debug(\"Registering icon pack:\", iconLoader.name);\n    if (\"loader\" in iconLoader) {\n      loaderStore.set(iconLoader.name, iconLoader.loader);\n    } else if (\"icons\" in iconLoader) {\n      iconsStore.set(iconLoader.name, iconLoader.icons);\n    } else {\n      log.error(\"Invalid icon loader:\", iconLoader);\n      throw new Error('Invalid icon loader. Must have either \"icons\" or \"loader\" property.');\n    }\n  }\n}, \"registerIconPacks\");\nvar getRegisteredIconData = /* @__PURE__ */__name(async (iconName, fallbackPrefix) => {\n  const data = stringToIcon(iconName, true, fallbackPrefix !== void 0);\n  if (!data) {\n    throw new Error(`Invalid icon name: ${iconName}`);\n  }\n  const prefix = data.prefix || fallbackPrefix;\n  if (!prefix) {\n    throw new Error(`Icon name must contain a prefix: ${iconName}`);\n  }\n  let icons = iconsStore.get(prefix);\n  if (!icons) {\n    const loader = loaderStore.get(prefix);\n    if (!loader) {\n      throw new Error(`Icon set not found: ${data.prefix}`);\n    }\n    try {\n      const loaded = await loader();\n      icons = {\n        ...loaded,\n        prefix\n      };\n      iconsStore.set(prefix, icons);\n    } catch (e) {\n      log.error(e);\n      throw new Error(`Failed to load icon set: ${data.prefix}`);\n    }\n  }\n  const iconData = getIconData(icons, data.name);\n  if (!iconData) {\n    throw new Error(`Icon not found: ${iconName}`);\n  }\n  return iconData;\n}, \"getRegisteredIconData\");\nvar isIconAvailable = /* @__PURE__ */__name(async iconName => {\n  try {\n    await getRegisteredIconData(iconName);\n    return true;\n  } catch {\n    return false;\n  }\n}, \"isIconAvailable\");\nvar getIconSVG = /* @__PURE__ */__name(async (iconName, customisations, extraAttributes) => {\n  let iconData;\n  try {\n    iconData = await getRegisteredIconData(iconName, customisations?.fallbackPrefix);\n  } catch (e) {\n    log.error(e);\n    iconData = unknownIcon;\n  }\n  const renderData = iconToSVG(iconData, customisations);\n  const svg = iconToHTML(replaceIDs(renderData.body), {\n    ...renderData.attributes,\n    ...extraAttributes\n  });\n  return svg;\n}, \"getIconSVG\");\n\n// src/rendering-util/createText.ts\nimport { select } from \"d3\";\n\n// src/rendering-util/handle-markdown-text.ts\nimport { marked } from \"marked\";\nimport { dedent } from \"ts-dedent\";\nfunction preprocessMarkdown(markdown, {\n  markdownAutoWrap\n}) {\n  const withoutBR = markdown.replace(/<br\\/>/g, \"\\n\");\n  const withoutMultipleNewlines = withoutBR.replace(/\\n{2,}/g, \"\\n\");\n  const withoutExtraSpaces = dedent(withoutMultipleNewlines);\n  if (markdownAutoWrap === false) {\n    return withoutExtraSpaces.replace(/ /g, \"&nbsp;\");\n  }\n  return withoutExtraSpaces;\n}\n__name(preprocessMarkdown, \"preprocessMarkdown\");\nfunction markdownToLines(markdown, config = {}) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown, config);\n  const nodes = marked.lexer(preprocessedMarkdown);\n  const lines = [[]];\n  let currentLine = 0;\n  function processNode(node, parentType = \"normal\") {\n    if (node.type === \"text\") {\n      const textLines = node.text.split(\"\\n\");\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n        textLine.split(\" \").forEach(word => {\n          word = word.replace(/&#39;/g, `'`);\n          if (word) {\n            lines[currentLine].push({\n              content: word,\n              type: parentType\n            });\n          }\n        });\n      });\n    } else if (node.type === \"strong\" || node.type === \"em\") {\n      node.tokens.forEach(contentNode => {\n        processNode(contentNode, node.type);\n      });\n    } else if (node.type === \"html\") {\n      lines[currentLine].push({\n        content: node.text,\n        type: \"normal\"\n      });\n    }\n  }\n  __name(processNode, \"processNode\");\n  nodes.forEach(treeNode => {\n    if (treeNode.type === \"paragraph\") {\n      treeNode.tokens?.forEach(contentNode => {\n        processNode(contentNode);\n      });\n    } else if (treeNode.type === \"html\") {\n      lines[currentLine].push({\n        content: treeNode.text,\n        type: \"normal\"\n      });\n    }\n  });\n  return lines;\n}\n__name(markdownToLines, \"markdownToLines\");\nfunction markdownToHTML(markdown, {\n  markdownAutoWrap\n} = {}) {\n  const nodes = marked.lexer(markdown);\n  function output(node) {\n    if (node.type === \"text\") {\n      if (markdownAutoWrap === false) {\n        return node.text.replace(/\\n */g, \"<br/>\").replace(/ /g, \"&nbsp;\");\n      }\n      return node.text.replace(/\\n */g, \"<br/>\");\n    } else if (node.type === \"strong\") {\n      return `<strong>${node.tokens?.map(output).join(\"\")}</strong>`;\n    } else if (node.type === \"em\") {\n      return `<em>${node.tokens?.map(output).join(\"\")}</em>`;\n    } else if (node.type === \"paragraph\") {\n      return `<p>${node.tokens?.map(output).join(\"\")}</p>`;\n    } else if (node.type === \"space\") {\n      return \"\";\n    } else if (node.type === \"html\") {\n      return `${node.text}`;\n    } else if (node.type === \"escape\") {\n      return node.text;\n    }\n    return `Unsupported markdown: ${node.type}`;\n  }\n  __name(output, \"output\");\n  return nodes.map(output).join(\"\");\n}\n__name(markdownToHTML, \"markdownToHTML\");\n\n// src/rendering-util/splitText.ts\nfunction splitTextToChars(text) {\n  if (Intl.Segmenter) {\n    return [...new Intl.Segmenter().segment(text)].map(s => s.segment);\n  }\n  return [...text];\n}\n__name(splitTextToChars, \"splitTextToChars\");\nfunction splitWordToFitWidth(checkFit, word) {\n  const characters = splitTextToChars(word.content);\n  return splitWordToFitWidthRecursion(checkFit, [], characters, word.type);\n}\n__name(splitWordToFitWidth, \"splitWordToFitWidth\");\nfunction splitWordToFitWidthRecursion(checkFit, usedChars, remainingChars, type) {\n  if (remainingChars.length === 0) {\n    return [{\n      content: usedChars.join(\"\"),\n      type\n    }, {\n      content: \"\",\n      type\n    }];\n  }\n  const [nextChar, ...rest] = remainingChars;\n  const newWord = [...usedChars, nextChar];\n  if (checkFit([{\n    content: newWord.join(\"\"),\n    type\n  }])) {\n    return splitWordToFitWidthRecursion(checkFit, newWord, rest, type);\n  }\n  if (usedChars.length === 0 && nextChar) {\n    usedChars.push(nextChar);\n    remainingChars.shift();\n  }\n  return [{\n    content: usedChars.join(\"\"),\n    type\n  }, {\n    content: remainingChars.join(\"\"),\n    type\n  }];\n}\n__name(splitWordToFitWidthRecursion, \"splitWordToFitWidthRecursion\");\nfunction splitLineToFitWidth(line, checkFit) {\n  if (line.some(({\n    content\n  }) => content.includes(\"\\n\"))) {\n    throw new Error(\"splitLineToFitWidth does not support newlines in the line\");\n  }\n  return splitLineToFitWidthRecursion(line, checkFit);\n}\n__name(splitLineToFitWidth, \"splitLineToFitWidth\");\nfunction splitLineToFitWidthRecursion(words, checkFit, lines = [], newLine = []) {\n  if (words.length === 0) {\n    if (newLine.length > 0) {\n      lines.push(newLine);\n    }\n    return lines.length > 0 ? lines : [];\n  }\n  let joiner = \"\";\n  if (words[0].content === \" \") {\n    joiner = \" \";\n    words.shift();\n  }\n  const nextWord = words.shift() ?? {\n    content: \" \",\n    type: \"normal\"\n  };\n  const lineWithNextWord = [...newLine];\n  if (joiner !== \"\") {\n    lineWithNextWord.push({\n      content: joiner,\n      type: \"normal\"\n    });\n  }\n  lineWithNextWord.push(nextWord);\n  if (checkFit(lineWithNextWord)) {\n    return splitLineToFitWidthRecursion(words, checkFit, lines, lineWithNextWord);\n  }\n  if (newLine.length > 0) {\n    lines.push(newLine);\n    words.unshift(nextWord);\n  } else if (nextWord.content) {\n    const [line, rest] = splitWordToFitWidth(checkFit, nextWord);\n    lines.push([line]);\n    if (rest.content) {\n      words.unshift(rest);\n    }\n  }\n  return splitLineToFitWidthRecursion(words, checkFit, lines);\n}\n__name(splitLineToFitWidthRecursion, \"splitLineToFitWidthRecursion\");\n\n// src/rendering-util/createText.ts\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\n__name(applyStyle, \"applyStyle\");\nasync function addHtmlSpan(element, node, width, classes, addBackground = false) {\n  const fo = element.append(\"foreignObject\");\n  fo.attr(\"width\", `${10 * width}px`);\n  fo.attr(\"height\", `${10 * width}px`);\n  const div = fo.append(\"xhtml:div\");\n  let label = node.label;\n  if (node.label && hasKatex(node.label)) {\n    label = await renderKatex(node.label.replace(common_default.lineBreakRegex, \"\\n\"), getConfig());\n  }\n  const labelClass = node.isNode ? \"nodeLabel\" : \"edgeLabel\";\n  const span = div.append(\"span\");\n  span.html(label);\n  applyStyle(span, node.labelStyle);\n  span.attr(\"class\", `${labelClass} ${classes}`);\n  applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"table-cell\");\n  div.style(\"white-space\", \"nowrap\");\n  div.style(\"line-height\", \"1.5\");\n  div.style(\"max-width\", width + \"px\");\n  div.style(\"text-align\", \"center\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n  if (addBackground) {\n    div.attr(\"class\", \"labelBkg\");\n  }\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style(\"display\", \"table\");\n    div.style(\"white-space\", \"break-spaces\");\n    div.style(\"width\", width + \"px\");\n    bbox = div.node().getBoundingClientRect();\n  }\n  return fo.node();\n}\n__name(addHtmlSpan, \"addHtmlSpan\");\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement.append(\"tspan\").attr(\"class\", \"text-outer-tspan\").attr(\"x\", 0).attr(\"y\", lineIndex * lineHeight - 0.1 + \"em\").attr(\"dy\", lineHeight + \"em\");\n}\n__name(createTspan, \"createTspan\");\nfunction computeWidthOfText(parentNode, lineHeight, line) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, line);\n  const textLength = testSpan.node().getComputedTextLength();\n  testElement.remove();\n  return textLength;\n}\n__name(computeWidthOfText, \"computeWidthOfText\");\nfunction computeDimensionOfText(parentNode, lineHeight, text) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, [{\n    content: text,\n    type: \"normal\"\n  }]);\n  const textDimension = testSpan.node()?.getBoundingClientRect();\n  if (textDimension) {\n    testElement.remove();\n  }\n  return textDimension;\n}\n__name(computeDimensionOfText, \"computeDimensionOfText\");\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append(\"g\");\n  const bkg = labelGroup.insert(\"rect\").attr(\"class\", \"background\").attr(\"style\", \"stroke: none\");\n  const textElement = labelGroup.append(\"text\").attr(\"y\", \"-10.1\");\n  let lineIndex = 0;\n  for (const line of structuredText) {\n    const checkWidth = /* @__PURE__ */__name(line2 => computeWidthOfText(labelGroup, lineHeight, line2) <= width, \"checkWidth\");\n    const linesUnderWidth = checkWidth(line) ? [line] : splitLineToFitWidth(line, checkWidth);\n    for (const preparedLine of linesUnderWidth) {\n      const tspan = createTspan(textElement, lineIndex, lineHeight);\n      updateTextContentAndStyles(tspan, preparedLine);\n      lineIndex++;\n    }\n  }\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg.attr(\"x\", bbox.x - padding).attr(\"y\", bbox.y - padding).attr(\"width\", bbox.width + 2 * padding).attr(\"height\", bbox.height + 2 * padding);\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\n__name(createFormattedText, \"createFormattedText\");\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text(\"\");\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan.append(\"tspan\").attr(\"font-style\", word.type === \"em\" ? \"italic\" : \"normal\").attr(\"class\", \"text-inner-tspan\").attr(\"font-weight\", word.type === \"strong\" ? \"bold\" : \"normal\");\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(\" \" + word.content);\n    }\n  });\n}\n__name(updateTextContentAndStyles, \"updateTextContentAndStyles\");\nasync function replaceIconSubstring(text) {\n  const pendingReplacements = [];\n  text.replace(/(fa[bklrs]?):fa-([\\w-]+)/g, (fullMatch, prefix, iconName) => {\n    pendingReplacements.push((async () => {\n      const registeredIconName = `${prefix}:${iconName}`;\n      if (await isIconAvailable(registeredIconName)) {\n        return await getIconSVG(registeredIconName, void 0, {\n          class: \"label-icon\"\n        });\n      } else {\n        return `<i class='${sanitizeText(fullMatch).replace(\":\", \" \")}'></i>`;\n      }\n    })());\n    return fullMatch;\n  });\n  const replacements = await Promise.all(pendingReplacements);\n  return text.replace(/(fa[bklrs]?):fa-([\\w-]+)/g, () => replacements.shift() ?? \"\");\n}\n__name(replaceIconSubstring, \"replaceIconSubstring\");\nvar createText = /* @__PURE__ */__name(async (el, text = \"\", {\n  style = \"\",\n  isTitle = false,\n  classes = \"\",\n  useHtmlLabels = true,\n  isNode = true,\n  width = 200,\n  addSvgBackground = false\n} = {}, config) => {\n  log.debug(\"XYZ createText\", text, style, isTitle, classes, useHtmlLabels, isNode, \"addSvgBackground: \", addSvgBackground);\n  if (useHtmlLabels) {\n    const htmlText = markdownToHTML(text, config);\n    const decodedReplacedText = await replaceIconSubstring(decodeEntities(htmlText));\n    const inputForKatex = text.replace(/\\\\\\\\/g, \"\\\\\");\n    const node = {\n      isNode,\n      label: hasKatex(text) ? inputForKatex : decodedReplacedText,\n      labelStyle: style.replace(\"fill:\", \"color:\")\n    };\n    const vertexNode = await addHtmlSpan(el, node, width, classes, addSvgBackground);\n    return vertexNode;\n  } else {\n    const sanitizeBR = text.replace(/<br\\s*\\/?>/g, \"<br/>\");\n    const structuredText = markdownToLines(sanitizeBR.replace(\"<br>\", \"<br/>\"), config);\n    const svgLabel = createFormattedText(width, el, structuredText, text ? addSvgBackground : false);\n    if (isNode) {\n      if (/stroke:/.exec(style)) {\n        style = style.replace(\"stroke:\", \"lineColor:\");\n      }\n      const nodeLabelTextStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/color:/g, \"fill:\");\n      select(svgLabel).attr(\"style\", nodeLabelTextStyle);\n    } else {\n      const edgeLabelRectStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/background:/g, \"fill:\");\n      select(svgLabel).select(\"rect\").attr(\"style\", edgeLabelRectStyle.replace(/background:/g, \"fill:\"));\n      const edgeLabelTextStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/color:/g, \"fill:\");\n      select(svgLabel).select(\"text\").attr(\"style\", edgeLabelTextStyle);\n    }\n    return svgLabel;\n  }\n}, \"createText\");\nexport { unknownIcon, registerIconPacks, getIconSVG, computeDimensionOfText, replaceIconSubstring, createText };","map":{"version":3,"names":["decodeEntities","__name","common_default","getConfig2","getConfig","hasKatex","log","renderKatex","sanitizeText2","sanitizeText","getIconData","iconToHTML","iconToSVG","replaceIDs","stringToIcon","unknownIcon","body","height","width","iconsStore","Map","loaderStore","registerIconPacks","iconLoaders","iconLoader","name","Error","debug","set","loader","icons","error","getRegisteredIconData","iconName","fallbackPrefix","data","prefix","get","loaded","e","iconData","isIconAvailable","getIconSVG","customisations","extraAttributes","renderData","svg","attributes","select","marked","dedent","preprocessMarkdown","markdown","markdownAutoWrap","withoutBR","replace","withoutMultipleNewlines","withoutExtraSpaces","markdownToLines","config","preprocessedMarkdown","nodes","lexer","lines","currentLine","processNode","node","parentType","type","textLines","text","split","forEach","textLine","index","push","word","content","tokens","contentNode","treeNode","markdownToHTML","output","map","join","splitTextToChars","Intl","Segmenter","segment","s","splitWordToFitWidth","checkFit","characters","splitWordToFitWidthRecursion","usedChars","remainingChars","length","nextChar","rest","newWord","shift","splitLineToFitWidth","line","some","includes","splitLineToFitWidthRecursion","words","newLine","joiner","nextWord","lineWithNextWord","unshift","applyStyle","dom","styleFn","attr","addHtmlSpan","element","classes","addBackground","fo","append","div","label","lineBreakRegex","labelClass","isNode","span","html","labelStyle","style","bbox","getBoundingClientRect","createTspan","textElement","lineIndex","lineHeight","computeWidthOfText","parentNode","testElement","testSpan","updateTextContentAndStyles","textLength","getComputedTextLength","remove","computeDimensionOfText","textDimension","createFormattedText","g","structuredText","labelGroup","bkg","insert","checkWidth","line2","linesUnderWidth","preparedLine","tspan","getBBox","padding","x","y","wrappedLine","innerTspan","replaceIconSubstring","pendingReplacements","fullMatch","registeredIconName","class","replacements","Promise","all","createText","el","isTitle","useHtmlLabels","addSvgBackground","htmlText","decodedReplacedText","inputForKatex","vertexNode","sanitizeBR","svgLabel","exec","nodeLabelTextStyle","edgeLabelRectStyle","edgeLabelTextStyle"],"sources":["D:/DBMS/DBMS Project/frontend/node_modules/mermaid/dist/chunks/mermaid.core/chunk-QESNASVV.mjs"],"sourcesContent":["import {\n  decodeEntities\n} from \"./chunk-55PJQP7W.mjs\";\nimport {\n  __name,\n  common_default,\n  getConfig2 as getConfig,\n  hasKatex,\n  log,\n  renderKatex,\n  sanitizeText2 as sanitizeText\n} from \"./chunk-3XYRH5AP.mjs\";\n\n// src/rendering-util/icons.ts\nimport { getIconData, iconToHTML, iconToSVG, replaceIDs, stringToIcon } from \"@iconify/utils\";\nvar unknownIcon = {\n  body: '<g><rect width=\"80\" height=\"80\" style=\"fill: #087ebf; stroke-width: 0px;\"/><text transform=\"translate(21.16 64.67)\" style=\"fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;\"><tspan x=\"0\" y=\"0\">?</tspan></text></g>',\n  height: 80,\n  width: 80\n};\nvar iconsStore = /* @__PURE__ */ new Map();\nvar loaderStore = /* @__PURE__ */ new Map();\nvar registerIconPacks = /* @__PURE__ */ __name((iconLoaders) => {\n  for (const iconLoader of iconLoaders) {\n    if (!iconLoader.name) {\n      throw new Error(\n        'Invalid icon loader. Must have a \"name\" property with non-empty string value.'\n      );\n    }\n    log.debug(\"Registering icon pack:\", iconLoader.name);\n    if (\"loader\" in iconLoader) {\n      loaderStore.set(iconLoader.name, iconLoader.loader);\n    } else if (\"icons\" in iconLoader) {\n      iconsStore.set(iconLoader.name, iconLoader.icons);\n    } else {\n      log.error(\"Invalid icon loader:\", iconLoader);\n      throw new Error('Invalid icon loader. Must have either \"icons\" or \"loader\" property.');\n    }\n  }\n}, \"registerIconPacks\");\nvar getRegisteredIconData = /* @__PURE__ */ __name(async (iconName, fallbackPrefix) => {\n  const data = stringToIcon(iconName, true, fallbackPrefix !== void 0);\n  if (!data) {\n    throw new Error(`Invalid icon name: ${iconName}`);\n  }\n  const prefix = data.prefix || fallbackPrefix;\n  if (!prefix) {\n    throw new Error(`Icon name must contain a prefix: ${iconName}`);\n  }\n  let icons = iconsStore.get(prefix);\n  if (!icons) {\n    const loader = loaderStore.get(prefix);\n    if (!loader) {\n      throw new Error(`Icon set not found: ${data.prefix}`);\n    }\n    try {\n      const loaded = await loader();\n      icons = { ...loaded, prefix };\n      iconsStore.set(prefix, icons);\n    } catch (e) {\n      log.error(e);\n      throw new Error(`Failed to load icon set: ${data.prefix}`);\n    }\n  }\n  const iconData = getIconData(icons, data.name);\n  if (!iconData) {\n    throw new Error(`Icon not found: ${iconName}`);\n  }\n  return iconData;\n}, \"getRegisteredIconData\");\nvar isIconAvailable = /* @__PURE__ */ __name(async (iconName) => {\n  try {\n    await getRegisteredIconData(iconName);\n    return true;\n  } catch {\n    return false;\n  }\n}, \"isIconAvailable\");\nvar getIconSVG = /* @__PURE__ */ __name(async (iconName, customisations, extraAttributes) => {\n  let iconData;\n  try {\n    iconData = await getRegisteredIconData(iconName, customisations?.fallbackPrefix);\n  } catch (e) {\n    log.error(e);\n    iconData = unknownIcon;\n  }\n  const renderData = iconToSVG(iconData, customisations);\n  const svg = iconToHTML(replaceIDs(renderData.body), {\n    ...renderData.attributes,\n    ...extraAttributes\n  });\n  return svg;\n}, \"getIconSVG\");\n\n// src/rendering-util/createText.ts\nimport { select } from \"d3\";\n\n// src/rendering-util/handle-markdown-text.ts\nimport { marked } from \"marked\";\nimport { dedent } from \"ts-dedent\";\nfunction preprocessMarkdown(markdown, { markdownAutoWrap }) {\n  const withoutBR = markdown.replace(/<br\\/>/g, \"\\n\");\n  const withoutMultipleNewlines = withoutBR.replace(/\\n{2,}/g, \"\\n\");\n  const withoutExtraSpaces = dedent(withoutMultipleNewlines);\n  if (markdownAutoWrap === false) {\n    return withoutExtraSpaces.replace(/ /g, \"&nbsp;\");\n  }\n  return withoutExtraSpaces;\n}\n__name(preprocessMarkdown, \"preprocessMarkdown\");\nfunction markdownToLines(markdown, config = {}) {\n  const preprocessedMarkdown = preprocessMarkdown(markdown, config);\n  const nodes = marked.lexer(preprocessedMarkdown);\n  const lines = [[]];\n  let currentLine = 0;\n  function processNode(node, parentType = \"normal\") {\n    if (node.type === \"text\") {\n      const textLines = node.text.split(\"\\n\");\n      textLines.forEach((textLine, index) => {\n        if (index !== 0) {\n          currentLine++;\n          lines.push([]);\n        }\n        textLine.split(\" \").forEach((word) => {\n          word = word.replace(/&#39;/g, `'`);\n          if (word) {\n            lines[currentLine].push({ content: word, type: parentType });\n          }\n        });\n      });\n    } else if (node.type === \"strong\" || node.type === \"em\") {\n      node.tokens.forEach((contentNode) => {\n        processNode(contentNode, node.type);\n      });\n    } else if (node.type === \"html\") {\n      lines[currentLine].push({ content: node.text, type: \"normal\" });\n    }\n  }\n  __name(processNode, \"processNode\");\n  nodes.forEach((treeNode) => {\n    if (treeNode.type === \"paragraph\") {\n      treeNode.tokens?.forEach((contentNode) => {\n        processNode(contentNode);\n      });\n    } else if (treeNode.type === \"html\") {\n      lines[currentLine].push({ content: treeNode.text, type: \"normal\" });\n    }\n  });\n  return lines;\n}\n__name(markdownToLines, \"markdownToLines\");\nfunction markdownToHTML(markdown, { markdownAutoWrap } = {}) {\n  const nodes = marked.lexer(markdown);\n  function output(node) {\n    if (node.type === \"text\") {\n      if (markdownAutoWrap === false) {\n        return node.text.replace(/\\n */g, \"<br/>\").replace(/ /g, \"&nbsp;\");\n      }\n      return node.text.replace(/\\n */g, \"<br/>\");\n    } else if (node.type === \"strong\") {\n      return `<strong>${node.tokens?.map(output).join(\"\")}</strong>`;\n    } else if (node.type === \"em\") {\n      return `<em>${node.tokens?.map(output).join(\"\")}</em>`;\n    } else if (node.type === \"paragraph\") {\n      return `<p>${node.tokens?.map(output).join(\"\")}</p>`;\n    } else if (node.type === \"space\") {\n      return \"\";\n    } else if (node.type === \"html\") {\n      return `${node.text}`;\n    } else if (node.type === \"escape\") {\n      return node.text;\n    }\n    return `Unsupported markdown: ${node.type}`;\n  }\n  __name(output, \"output\");\n  return nodes.map(output).join(\"\");\n}\n__name(markdownToHTML, \"markdownToHTML\");\n\n// src/rendering-util/splitText.ts\nfunction splitTextToChars(text) {\n  if (Intl.Segmenter) {\n    return [...new Intl.Segmenter().segment(text)].map((s) => s.segment);\n  }\n  return [...text];\n}\n__name(splitTextToChars, \"splitTextToChars\");\nfunction splitWordToFitWidth(checkFit, word) {\n  const characters = splitTextToChars(word.content);\n  return splitWordToFitWidthRecursion(checkFit, [], characters, word.type);\n}\n__name(splitWordToFitWidth, \"splitWordToFitWidth\");\nfunction splitWordToFitWidthRecursion(checkFit, usedChars, remainingChars, type) {\n  if (remainingChars.length === 0) {\n    return [\n      { content: usedChars.join(\"\"), type },\n      { content: \"\", type }\n    ];\n  }\n  const [nextChar, ...rest] = remainingChars;\n  const newWord = [...usedChars, nextChar];\n  if (checkFit([{ content: newWord.join(\"\"), type }])) {\n    return splitWordToFitWidthRecursion(checkFit, newWord, rest, type);\n  }\n  if (usedChars.length === 0 && nextChar) {\n    usedChars.push(nextChar);\n    remainingChars.shift();\n  }\n  return [\n    { content: usedChars.join(\"\"), type },\n    { content: remainingChars.join(\"\"), type }\n  ];\n}\n__name(splitWordToFitWidthRecursion, \"splitWordToFitWidthRecursion\");\nfunction splitLineToFitWidth(line, checkFit) {\n  if (line.some(({ content }) => content.includes(\"\\n\"))) {\n    throw new Error(\"splitLineToFitWidth does not support newlines in the line\");\n  }\n  return splitLineToFitWidthRecursion(line, checkFit);\n}\n__name(splitLineToFitWidth, \"splitLineToFitWidth\");\nfunction splitLineToFitWidthRecursion(words, checkFit, lines = [], newLine = []) {\n  if (words.length === 0) {\n    if (newLine.length > 0) {\n      lines.push(newLine);\n    }\n    return lines.length > 0 ? lines : [];\n  }\n  let joiner = \"\";\n  if (words[0].content === \" \") {\n    joiner = \" \";\n    words.shift();\n  }\n  const nextWord = words.shift() ?? { content: \" \", type: \"normal\" };\n  const lineWithNextWord = [...newLine];\n  if (joiner !== \"\") {\n    lineWithNextWord.push({ content: joiner, type: \"normal\" });\n  }\n  lineWithNextWord.push(nextWord);\n  if (checkFit(lineWithNextWord)) {\n    return splitLineToFitWidthRecursion(words, checkFit, lines, lineWithNextWord);\n  }\n  if (newLine.length > 0) {\n    lines.push(newLine);\n    words.unshift(nextWord);\n  } else if (nextWord.content) {\n    const [line, rest] = splitWordToFitWidth(checkFit, nextWord);\n    lines.push([line]);\n    if (rest.content) {\n      words.unshift(rest);\n    }\n  }\n  return splitLineToFitWidthRecursion(words, checkFit, lines);\n}\n__name(splitLineToFitWidthRecursion, \"splitLineToFitWidthRecursion\");\n\n// src/rendering-util/createText.ts\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr(\"style\", styleFn);\n  }\n}\n__name(applyStyle, \"applyStyle\");\nasync function addHtmlSpan(element, node, width, classes, addBackground = false) {\n  const fo = element.append(\"foreignObject\");\n  fo.attr(\"width\", `${10 * width}px`);\n  fo.attr(\"height\", `${10 * width}px`);\n  const div = fo.append(\"xhtml:div\");\n  let label = node.label;\n  if (node.label && hasKatex(node.label)) {\n    label = await renderKatex(node.label.replace(common_default.lineBreakRegex, \"\\n\"), getConfig());\n  }\n  const labelClass = node.isNode ? \"nodeLabel\" : \"edgeLabel\";\n  const span = div.append(\"span\");\n  span.html(label);\n  applyStyle(span, node.labelStyle);\n  span.attr(\"class\", `${labelClass} ${classes}`);\n  applyStyle(div, node.labelStyle);\n  div.style(\"display\", \"table-cell\");\n  div.style(\"white-space\", \"nowrap\");\n  div.style(\"line-height\", \"1.5\");\n  div.style(\"max-width\", width + \"px\");\n  div.style(\"text-align\", \"center\");\n  div.attr(\"xmlns\", \"http://www.w3.org/1999/xhtml\");\n  if (addBackground) {\n    div.attr(\"class\", \"labelBkg\");\n  }\n  let bbox = div.node().getBoundingClientRect();\n  if (bbox.width === width) {\n    div.style(\"display\", \"table\");\n    div.style(\"white-space\", \"break-spaces\");\n    div.style(\"width\", width + \"px\");\n    bbox = div.node().getBoundingClientRect();\n  }\n  return fo.node();\n}\n__name(addHtmlSpan, \"addHtmlSpan\");\nfunction createTspan(textElement, lineIndex, lineHeight) {\n  return textElement.append(\"tspan\").attr(\"class\", \"text-outer-tspan\").attr(\"x\", 0).attr(\"y\", lineIndex * lineHeight - 0.1 + \"em\").attr(\"dy\", lineHeight + \"em\");\n}\n__name(createTspan, \"createTspan\");\nfunction computeWidthOfText(parentNode, lineHeight, line) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, line);\n  const textLength = testSpan.node().getComputedTextLength();\n  testElement.remove();\n  return textLength;\n}\n__name(computeWidthOfText, \"computeWidthOfText\");\nfunction computeDimensionOfText(parentNode, lineHeight, text) {\n  const testElement = parentNode.append(\"text\");\n  const testSpan = createTspan(testElement, 1, lineHeight);\n  updateTextContentAndStyles(testSpan, [{ content: text, type: \"normal\" }]);\n  const textDimension = testSpan.node()?.getBoundingClientRect();\n  if (textDimension) {\n    testElement.remove();\n  }\n  return textDimension;\n}\n__name(computeDimensionOfText, \"computeDimensionOfText\");\nfunction createFormattedText(width, g, structuredText, addBackground = false) {\n  const lineHeight = 1.1;\n  const labelGroup = g.append(\"g\");\n  const bkg = labelGroup.insert(\"rect\").attr(\"class\", \"background\").attr(\"style\", \"stroke: none\");\n  const textElement = labelGroup.append(\"text\").attr(\"y\", \"-10.1\");\n  let lineIndex = 0;\n  for (const line of structuredText) {\n    const checkWidth = /* @__PURE__ */ __name((line2) => computeWidthOfText(labelGroup, lineHeight, line2) <= width, \"checkWidth\");\n    const linesUnderWidth = checkWidth(line) ? [line] : splitLineToFitWidth(line, checkWidth);\n    for (const preparedLine of linesUnderWidth) {\n      const tspan = createTspan(textElement, lineIndex, lineHeight);\n      updateTextContentAndStyles(tspan, preparedLine);\n      lineIndex++;\n    }\n  }\n  if (addBackground) {\n    const bbox = textElement.node().getBBox();\n    const padding = 2;\n    bkg.attr(\"x\", bbox.x - padding).attr(\"y\", bbox.y - padding).attr(\"width\", bbox.width + 2 * padding).attr(\"height\", bbox.height + 2 * padding);\n    return labelGroup.node();\n  } else {\n    return textElement.node();\n  }\n}\n__name(createFormattedText, \"createFormattedText\");\nfunction updateTextContentAndStyles(tspan, wrappedLine) {\n  tspan.text(\"\");\n  wrappedLine.forEach((word, index) => {\n    const innerTspan = tspan.append(\"tspan\").attr(\"font-style\", word.type === \"em\" ? \"italic\" : \"normal\").attr(\"class\", \"text-inner-tspan\").attr(\"font-weight\", word.type === \"strong\" ? \"bold\" : \"normal\");\n    if (index === 0) {\n      innerTspan.text(word.content);\n    } else {\n      innerTspan.text(\" \" + word.content);\n    }\n  });\n}\n__name(updateTextContentAndStyles, \"updateTextContentAndStyles\");\nasync function replaceIconSubstring(text) {\n  const pendingReplacements = [];\n  text.replace(/(fa[bklrs]?):fa-([\\w-]+)/g, (fullMatch, prefix, iconName) => {\n    pendingReplacements.push(\n      (async () => {\n        const registeredIconName = `${prefix}:${iconName}`;\n        if (await isIconAvailable(registeredIconName)) {\n          return await getIconSVG(registeredIconName, void 0, { class: \"label-icon\" });\n        } else {\n          return `<i class='${sanitizeText(fullMatch).replace(\":\", \" \")}'></i>`;\n        }\n      })()\n    );\n    return fullMatch;\n  });\n  const replacements = await Promise.all(pendingReplacements);\n  return text.replace(/(fa[bklrs]?):fa-([\\w-]+)/g, () => replacements.shift() ?? \"\");\n}\n__name(replaceIconSubstring, \"replaceIconSubstring\");\nvar createText = /* @__PURE__ */ __name(async (el, text = \"\", {\n  style = \"\",\n  isTitle = false,\n  classes = \"\",\n  useHtmlLabels = true,\n  isNode = true,\n  width = 200,\n  addSvgBackground = false\n} = {}, config) => {\n  log.debug(\n    \"XYZ createText\",\n    text,\n    style,\n    isTitle,\n    classes,\n    useHtmlLabels,\n    isNode,\n    \"addSvgBackground: \",\n    addSvgBackground\n  );\n  if (useHtmlLabels) {\n    const htmlText = markdownToHTML(text, config);\n    const decodedReplacedText = await replaceIconSubstring(decodeEntities(htmlText));\n    const inputForKatex = text.replace(/\\\\\\\\/g, \"\\\\\");\n    const node = {\n      isNode,\n      label: hasKatex(text) ? inputForKatex : decodedReplacedText,\n      labelStyle: style.replace(\"fill:\", \"color:\")\n    };\n    const vertexNode = await addHtmlSpan(el, node, width, classes, addSvgBackground);\n    return vertexNode;\n  } else {\n    const sanitizeBR = text.replace(/<br\\s*\\/?>/g, \"<br/>\");\n    const structuredText = markdownToLines(sanitizeBR.replace(\"<br>\", \"<br/>\"), config);\n    const svgLabel = createFormattedText(\n      width,\n      el,\n      structuredText,\n      text ? addSvgBackground : false\n    );\n    if (isNode) {\n      if (/stroke:/.exec(style)) {\n        style = style.replace(\"stroke:\", \"lineColor:\");\n      }\n      const nodeLabelTextStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/color:/g, \"fill:\");\n      select(svgLabel).attr(\"style\", nodeLabelTextStyle);\n    } else {\n      const edgeLabelRectStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/background:/g, \"fill:\");\n      select(svgLabel).select(\"rect\").attr(\"style\", edgeLabelRectStyle.replace(/background:/g, \"fill:\"));\n      const edgeLabelTextStyle = style.replace(/stroke:[^;]+;?/g, \"\").replace(/stroke-width:[^;]+;?/g, \"\").replace(/fill:[^;]+;?/g, \"\").replace(/color:/g, \"fill:\");\n      select(svgLabel).select(\"text\").attr(\"style\", edgeLabelTextStyle);\n    }\n    return svgLabel;\n  }\n}, \"createText\");\n\nexport {\n  unknownIcon,\n  registerIconPacks,\n  getIconSVG,\n  computeDimensionOfText,\n  replaceIconSubstring,\n  createText\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}