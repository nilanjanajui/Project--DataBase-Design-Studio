{"ast":null,"code":"/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { Position } from 'vscode-languageserver-types';\nimport { tokenToRange } from '../utils/cst-utils.js';\nexport class CstNodeBuilder {\n  constructor() {\n    this.nodeStack = [];\n  }\n  get current() {\n    var _a;\n    return (_a = this.nodeStack[this.nodeStack.length - 1]) !== null && _a !== void 0 ? _a : this.rootNode;\n  }\n  buildRootNode(input) {\n    this.rootNode = new RootCstNodeImpl(input);\n    this.rootNode.root = this.rootNode;\n    this.nodeStack = [this.rootNode];\n    return this.rootNode;\n  }\n  buildCompositeNode(feature) {\n    const compositeNode = new CompositeCstNodeImpl();\n    compositeNode.grammarSource = feature;\n    compositeNode.root = this.rootNode;\n    this.current.content.push(compositeNode);\n    this.nodeStack.push(compositeNode);\n    return compositeNode;\n  }\n  buildLeafNode(token, feature) {\n    const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, !feature);\n    leafNode.grammarSource = feature;\n    leafNode.root = this.rootNode;\n    this.current.content.push(leafNode);\n    return leafNode;\n  }\n  removeNode(node) {\n    const parent = node.container;\n    if (parent) {\n      const index = parent.content.indexOf(node);\n      if (index >= 0) {\n        parent.content.splice(index, 1);\n      }\n    }\n  }\n  addHiddenNodes(tokens) {\n    const nodes = [];\n    for (const token of tokens) {\n      const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, true);\n      leafNode.root = this.rootNode;\n      nodes.push(leafNode);\n    }\n    let current = this.current;\n    let added = false;\n    // If we are within a composite node, we add the hidden nodes to the content\n    if (current.content.length > 0) {\n      current.content.push(...nodes);\n      return;\n    }\n    // Otherwise we are at a newly created node\n    // Instead of adding the hidden nodes here, we search for the first parent node with content\n    while (current.container) {\n      const index = current.container.content.indexOf(current);\n      if (index > 0) {\n        // Add the hidden nodes before the current node\n        current.container.content.splice(index, 0, ...nodes);\n        added = true;\n        break;\n      }\n      current = current.container;\n    }\n    // If we arrive at the root node, we add the hidden nodes at the beginning\n    // This is the case if the hidden nodes are the first nodes in the tree\n    if (!added) {\n      this.rootNode.content.unshift(...nodes);\n    }\n  }\n  construct(item) {\n    const current = this.current;\n    // The specified item could be a datatype ($type is symbol) or a fragment ($type is undefined)\n    // Only if the $type is a string, we actually assign the element\n    if (typeof item.$type === 'string') {\n      this.current.astNode = item;\n    }\n    item.$cstNode = current;\n    const node = this.nodeStack.pop();\n    // Empty composite nodes are not valid\n    // Simply remove the node from the tree\n    if ((node === null || node === void 0 ? void 0 : node.content.length) === 0) {\n      this.removeNode(node);\n    }\n  }\n}\nexport class AbstractCstNode {\n  /** @deprecated use `container` instead. */\n  get parent() {\n    return this.container;\n  }\n  /** @deprecated use `grammarSource` instead. */\n  get feature() {\n    return this.grammarSource;\n  }\n  get hidden() {\n    return false;\n  }\n  get astNode() {\n    var _a, _b;\n    const node = typeof ((_a = this._astNode) === null || _a === void 0 ? void 0 : _a.$type) === 'string' ? this._astNode : (_b = this.container) === null || _b === void 0 ? void 0 : _b.astNode;\n    if (!node) {\n      throw new Error('This node has no associated AST element');\n    }\n    return node;\n  }\n  set astNode(value) {\n    this._astNode = value;\n  }\n  /** @deprecated use `astNode` instead. */\n  get element() {\n    return this.astNode;\n  }\n  get text() {\n    return this.root.fullText.substring(this.offset, this.end);\n  }\n}\nexport class LeafCstNodeImpl extends AbstractCstNode {\n  get offset() {\n    return this._offset;\n  }\n  get length() {\n    return this._length;\n  }\n  get end() {\n    return this._offset + this._length;\n  }\n  get hidden() {\n    return this._hidden;\n  }\n  get tokenType() {\n    return this._tokenType;\n  }\n  get range() {\n    return this._range;\n  }\n  constructor(offset, length, range, tokenType, hidden = false) {\n    super();\n    this._hidden = hidden;\n    this._offset = offset;\n    this._tokenType = tokenType;\n    this._length = length;\n    this._range = range;\n  }\n}\nexport class CompositeCstNodeImpl extends AbstractCstNode {\n  constructor() {\n    super(...arguments);\n    this.content = new CstNodeContainer(this);\n  }\n  /** @deprecated use `content` instead. */\n  get children() {\n    return this.content;\n  }\n  get offset() {\n    var _a, _b;\n    return (_b = (_a = this.firstNonHiddenNode) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0;\n  }\n  get length() {\n    return this.end - this.offset;\n  }\n  get end() {\n    var _a, _b;\n    return (_b = (_a = this.lastNonHiddenNode) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : 0;\n  }\n  get range() {\n    const firstNode = this.firstNonHiddenNode;\n    const lastNode = this.lastNonHiddenNode;\n    if (firstNode && lastNode) {\n      if (this._rangeCache === undefined) {\n        const {\n          range: firstRange\n        } = firstNode;\n        const {\n          range: lastRange\n        } = lastNode;\n        this._rangeCache = {\n          start: firstRange.start,\n          end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end\n        };\n      }\n      return this._rangeCache;\n    } else {\n      return {\n        start: Position.create(0, 0),\n        end: Position.create(0, 0)\n      };\n    }\n  }\n  get firstNonHiddenNode() {\n    for (const child of this.content) {\n      if (!child.hidden) {\n        return child;\n      }\n    }\n    return this.content[0];\n  }\n  get lastNonHiddenNode() {\n    for (let i = this.content.length - 1; i >= 0; i--) {\n      const child = this.content[i];\n      if (!child.hidden) {\n        return child;\n      }\n    }\n    return this.content[this.content.length - 1];\n  }\n}\nclass CstNodeContainer extends Array {\n  constructor(parent) {\n    super();\n    this.parent = parent;\n    Object.setPrototypeOf(this, CstNodeContainer.prototype);\n  }\n  push(...items) {\n    this.addParents(items);\n    return super.push(...items);\n  }\n  unshift(...items) {\n    this.addParents(items);\n    return super.unshift(...items);\n  }\n  splice(start, count, ...items) {\n    this.addParents(items);\n    return super.splice(start, count, ...items);\n  }\n  addParents(items) {\n    for (const item of items) {\n      item.container = this.parent;\n    }\n  }\n}\nexport class RootCstNodeImpl extends CompositeCstNodeImpl {\n  get text() {\n    return this._text.substring(this.offset, this.end);\n  }\n  get fullText() {\n    return this._text;\n  }\n  constructor(input) {\n    super();\n    this._text = '';\n    this._text = input !== null && input !== void 0 ? input : '';\n  }\n}","map":{"version":3,"names":["Position","tokenToRange","CstNodeBuilder","constructor","nodeStack","current","_a","length","rootNode","buildRootNode","input","RootCstNodeImpl","root","buildCompositeNode","feature","compositeNode","CompositeCstNodeImpl","grammarSource","content","push","buildLeafNode","token","leafNode","LeafCstNodeImpl","startOffset","image","tokenType","removeNode","node","parent","container","index","indexOf","splice","addHiddenNodes","tokens","nodes","added","unshift","construct","item","$type","astNode","$cstNode","pop","AbstractCstNode","hidden","_astNode","_b","Error","value","element","text","fullText","substring","offset","end","_offset","_length","_hidden","_tokenType","range","_range","CstNodeContainer","children","firstNonHiddenNode","lastNonHiddenNode","firstNode","lastNode","_rangeCache","undefined","firstRange","lastRange","start","line","create","child","i","Array","Object","setPrototypeOf","prototype","items","addParents","count","_text"],"sources":["D:\\DBMS\\DBMS Project\\frontend\\node_modules\\langium\\src\\parser\\cst-node-builder.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { IToken, TokenType } from 'chevrotain';\r\nimport type { Range } from 'vscode-languageserver-types';\r\nimport type { AbstractElement } from '../languages/generated/ast.js';\r\nimport type { AstNode, CompositeCstNode, CstNode, LeafCstNode, RootCstNode } from '../syntax-tree.js';\r\nimport { Position } from 'vscode-languageserver-types';\r\nimport { tokenToRange } from '../utils/cst-utils.js';\r\n\r\nexport class CstNodeBuilder {\r\n\r\n    private rootNode!: RootCstNodeImpl;\r\n    private nodeStack: CompositeCstNodeImpl[] = [];\r\n\r\n    get current(): CompositeCstNodeImpl {\r\n        return this.nodeStack[this.nodeStack.length - 1] ?? this.rootNode;\r\n    }\r\n\r\n    buildRootNode(input: string): RootCstNode {\r\n        this.rootNode = new RootCstNodeImpl(input);\r\n        this.rootNode.root = this.rootNode;\r\n        this.nodeStack = [this.rootNode];\r\n        return this.rootNode;\r\n    }\r\n\r\n    buildCompositeNode(feature: AbstractElement): CompositeCstNode {\r\n        const compositeNode = new CompositeCstNodeImpl();\r\n        compositeNode.grammarSource = feature;\r\n        compositeNode.root = this.rootNode;\r\n        this.current.content.push(compositeNode);\r\n        this.nodeStack.push(compositeNode);\r\n        return compositeNode;\r\n    }\r\n\r\n    buildLeafNode(token: IToken, feature?: AbstractElement): LeafCstNode {\r\n        const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, !feature);\r\n        leafNode.grammarSource = feature;\r\n        leafNode.root = this.rootNode;\r\n        this.current.content.push(leafNode);\r\n        return leafNode;\r\n    }\r\n\r\n    removeNode(node: CstNode): void {\r\n        const parent = node.container;\r\n        if (parent) {\r\n            const index = parent.content.indexOf(node);\r\n            if (index >= 0) {\r\n                parent.content.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    addHiddenNodes(tokens: IToken[]): void {\r\n        const nodes: LeafCstNode[] = [];\r\n        for (const token of tokens) {\r\n            const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, true);\r\n            leafNode.root = this.rootNode;\r\n            nodes.push(leafNode);\r\n        }\r\n        let current: CompositeCstNode = this.current;\r\n        let added = false;\r\n        // If we are within a composite node, we add the hidden nodes to the content\r\n        if (current.content.length > 0) {\r\n            current.content.push(...nodes);\r\n            return;\r\n        }\r\n        // Otherwise we are at a newly created node\r\n        // Instead of adding the hidden nodes here, we search for the first parent node with content\r\n        while (current.container) {\r\n            const index = current.container.content.indexOf(current);\r\n            if (index > 0) {\r\n                // Add the hidden nodes before the current node\r\n                current.container.content.splice(index, 0, ...nodes);\r\n                added = true;\r\n                break;\r\n            }\r\n            current = current.container;\r\n        }\r\n        // If we arrive at the root node, we add the hidden nodes at the beginning\r\n        // This is the case if the hidden nodes are the first nodes in the tree\r\n        if (!added) {\r\n            this.rootNode.content.unshift(...nodes);\r\n        }\r\n    }\r\n\r\n    construct(item: { $type: string | symbol | undefined, $cstNode: CstNode }): void {\r\n        const current: CstNode = this.current;\r\n        // The specified item could be a datatype ($type is symbol) or a fragment ($type is undefined)\r\n        // Only if the $type is a string, we actually assign the element\r\n        if (typeof item.$type === 'string') {\r\n            this.current.astNode = <AstNode>item;\r\n        }\r\n        item.$cstNode = current;\r\n        const node = this.nodeStack.pop();\r\n        // Empty composite nodes are not valid\r\n        // Simply remove the node from the tree\r\n        if (node?.content.length === 0) {\r\n            this.removeNode(node);\r\n        }\r\n    }\r\n}\r\n\r\nexport abstract class AbstractCstNode implements CstNode {\r\n    abstract get offset(): number;\r\n    abstract get length(): number;\r\n    abstract get end(): number;\r\n    abstract get range(): Range;\r\n\r\n    container?: CompositeCstNode;\r\n    grammarSource?: AbstractElement;\r\n    root: RootCstNode;\r\n    private _astNode?: AstNode;\r\n\r\n    /** @deprecated use `container` instead. */\r\n    get parent(): CompositeCstNode | undefined {\r\n        return this.container;\r\n    }\r\n\r\n    /** @deprecated use `grammarSource` instead. */\r\n    get feature(): AbstractElement | undefined {\r\n        return this.grammarSource;\r\n    }\r\n\r\n    get hidden(): boolean {\r\n        return false;\r\n    }\r\n\r\n    get astNode(): AstNode {\r\n        const node = typeof this._astNode?.$type === 'string' ? this._astNode : this.container?.astNode;\r\n        if (!node) {\r\n            throw new Error('This node has no associated AST element');\r\n        }\r\n        return node;\r\n    }\r\n\r\n    set astNode(value: AstNode | undefined) {\r\n        this._astNode = value;\r\n    }\r\n\r\n    /** @deprecated use `astNode` instead. */\r\n    get element(): AstNode {\r\n        return this.astNode;\r\n    }\r\n\r\n    get text(): string {\r\n        return this.root.fullText.substring(this.offset, this.end);\r\n    }\r\n}\r\n\r\nexport class LeafCstNodeImpl extends AbstractCstNode implements LeafCstNode {\r\n    get offset(): number {\r\n        return this._offset;\r\n    }\r\n\r\n    get length(): number {\r\n        return this._length;\r\n    }\r\n\r\n    get end(): number {\r\n        return this._offset + this._length;\r\n    }\r\n\r\n    override get hidden(): boolean {\r\n        return this._hidden;\r\n    }\r\n\r\n    get tokenType(): TokenType {\r\n        return this._tokenType;\r\n    }\r\n\r\n    get range(): Range {\r\n        return this._range;\r\n    }\r\n\r\n    private _hidden: boolean;\r\n    private _offset: number;\r\n    private _length: number;\r\n    private _range: Range;\r\n    private _tokenType: TokenType;\r\n\r\n    constructor(offset: number, length: number, range: Range, tokenType: TokenType, hidden = false) {\r\n        super();\r\n        this._hidden = hidden;\r\n        this._offset = offset;\r\n        this._tokenType = tokenType;\r\n        this._length = length;\r\n        this._range = range;\r\n    }\r\n}\r\n\r\nexport class CompositeCstNodeImpl extends AbstractCstNode implements CompositeCstNode {\r\n    readonly content: CstNode[] = new CstNodeContainer(this);\r\n    private _rangeCache?: Range;\r\n\r\n    /** @deprecated use `content` instead. */\r\n    get children(): CstNode[] {\r\n        return this.content;\r\n    }\r\n\r\n    get offset(): number {\r\n        return this.firstNonHiddenNode?.offset ?? 0;\r\n    }\r\n\r\n    get length(): number {\r\n        return this.end - this.offset;\r\n    }\r\n\r\n    get end(): number {\r\n        return this.lastNonHiddenNode?.end ?? 0;\r\n    }\r\n\r\n    get range(): Range {\r\n        const firstNode = this.firstNonHiddenNode;\r\n        const lastNode = this.lastNonHiddenNode;\r\n        if (firstNode && lastNode) {\r\n            if (this._rangeCache === undefined) {\r\n                const { range: firstRange } = firstNode;\r\n                const { range: lastRange } = lastNode;\r\n                this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };\r\n            }\r\n            return this._rangeCache;\r\n        } else {\r\n            return { start: Position.create(0, 0), end: Position.create(0, 0) };\r\n        }\r\n    }\r\n\r\n    private get firstNonHiddenNode(): CstNode | undefined {\r\n        for (const child of this.content) {\r\n            if (!child.hidden) {\r\n                return child;\r\n            }\r\n        }\r\n        return this.content[0];\r\n    }\r\n\r\n    private get lastNonHiddenNode(): CstNode | undefined {\r\n        for (let i = this.content.length - 1; i >= 0; i--) {\r\n            const child = this.content[i];\r\n            if (!child.hidden) {\r\n                return child;\r\n            }\r\n        }\r\n        return this.content[this.content.length - 1];\r\n    }\r\n}\r\n\r\nclass CstNodeContainer extends Array<CstNode> {\r\n    readonly parent: CompositeCstNode;\r\n\r\n    constructor(parent: CompositeCstNode) {\r\n        super();\r\n        this.parent = parent;\r\n        Object.setPrototypeOf(this, CstNodeContainer.prototype);\r\n    }\r\n\r\n    override push(...items: CstNode[]): number {\r\n        this.addParents(items);\r\n        return super.push(...items);\r\n    }\r\n\r\n    override unshift(...items: CstNode[]): number {\r\n        this.addParents(items);\r\n        return super.unshift(...items);\r\n    }\r\n\r\n    override splice(start: number, count: number, ...items: CstNode[]): CstNode[] {\r\n        this.addParents(items);\r\n        return super.splice(start, count, ...items);\r\n    }\r\n\r\n    private addParents(items: CstNode[]): void {\r\n        for (const item of items) {\r\n            (<AbstractCstNode>item).container = this.parent;\r\n        }\r\n    }\r\n}\r\n\r\nexport class RootCstNodeImpl extends CompositeCstNodeImpl implements RootCstNode {\r\n    private _text = '';\r\n\r\n    override get text(): string {\r\n        return this._text.substring(this.offset, this.end);\r\n    }\r\n\r\n    get fullText(): string {\r\n        return this._text;\r\n    }\r\n\r\n    constructor(input?: string) {\r\n        super();\r\n        this._text = input ?? '';\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}