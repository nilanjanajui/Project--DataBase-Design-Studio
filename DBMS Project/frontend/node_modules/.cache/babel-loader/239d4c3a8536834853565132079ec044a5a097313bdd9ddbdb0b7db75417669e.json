{"ast":null,"code":"/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nimport { MapScope, StreamScope } from './scope.js';\nimport { getDocument } from '../utils/ast-utils.js';\nimport { stream } from '../utils/stream.js';\nimport { WorkspaceCache } from '../utils/caching.js';\nexport class DefaultScopeProvider {\n  constructor(services) {\n    this.reflection = services.shared.AstReflection;\n    this.nameProvider = services.references.NameProvider;\n    this.descriptions = services.workspace.AstNodeDescriptionProvider;\n    this.indexManager = services.shared.workspace.IndexManager;\n    this.globalScopeCache = new WorkspaceCache(services.shared);\n  }\n  getScope(context) {\n    const scopes = [];\n    const referenceType = this.reflection.getReferenceType(context);\n    const precomputed = getDocument(context.container).precomputedScopes;\n    if (precomputed) {\n      let currentNode = context.container;\n      do {\n        const allDescriptions = precomputed.get(currentNode);\n        if (allDescriptions.length > 0) {\n          scopes.push(stream(allDescriptions).filter(desc => this.reflection.isSubtype(desc.type, referenceType)));\n        }\n        currentNode = currentNode.$container;\n      } while (currentNode);\n    }\n    let result = this.getGlobalScope(referenceType, context);\n    for (let i = scopes.length - 1; i >= 0; i--) {\n      result = this.createScope(scopes[i], result);\n    }\n    return result;\n  }\n  /**\n   * Create a scope for the given collection of AST node descriptions.\n   */\n  createScope(elements, outerScope, options) {\n    return new StreamScope(stream(elements), outerScope, options);\n  }\n  /**\n   * Create a scope for the given collection of AST nodes, which need to be transformed into respective\n   * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.\n   */\n  createScopeForNodes(elements, outerScope, options) {\n    const s = stream(elements).map(e => {\n      const name = this.nameProvider.getName(e);\n      if (name) {\n        return this.descriptions.createDescription(e, name);\n      }\n      return undefined;\n    }).nonNullable();\n    return new StreamScope(s, outerScope, options);\n  }\n  /**\n   * Create a global scope filtered for the given reference type.\n   */\n  getGlobalScope(referenceType, _context) {\n    return this.globalScopeCache.get(referenceType, () => new MapScope(this.indexManager.allElements(referenceType)));\n  }\n}","map":{"version":3,"names":["MapScope","StreamScope","getDocument","stream","WorkspaceCache","DefaultScopeProvider","constructor","services","reflection","shared","AstReflection","nameProvider","references","NameProvider","descriptions","workspace","AstNodeDescriptionProvider","indexManager","IndexManager","globalScopeCache","getScope","context","scopes","referenceType","getReferenceType","precomputed","container","precomputedScopes","currentNode","allDescriptions","get","length","push","filter","desc","isSubtype","type","$container","result","getGlobalScope","i","createScope","elements","outerScope","options","createScopeForNodes","s","map","e","name","getName","createDescription","undefined","nonNullable","_context","allElements"],"sources":["D:\\DBMS\\DBMS Project\\frontend\\node_modules\\langium\\src\\references\\scope-provider.ts"],"sourcesContent":["/******************************************************************************\r\n * Copyright 2021-2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumCoreServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription, AstReflection, ReferenceInfo } from '../syntax-tree.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport type { AstNodeDescriptionProvider } from '../workspace/ast-descriptions.js';\r\nimport type { IndexManager } from '../workspace/index-manager.js';\r\nimport type { NameProvider } from './name-provider.js';\r\nimport type { Scope, ScopeOptions} from './scope.js';\r\nimport { MapScope, StreamScope } from './scope.js';\r\nimport { getDocument } from '../utils/ast-utils.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport { WorkspaceCache } from '../utils/caching.js';\r\n\r\n/**\r\n * Language-specific service for determining the scope of target elements visible in a specific cross-reference context.\r\n */\r\nexport interface ScopeProvider {\r\n\r\n    /**\r\n     * Return a scope describing what elements are visible for the given AST node and cross-reference\r\n     * identifier.\r\n     *\r\n     * @param context Information about the reference for which a scope is requested.\r\n     */\r\n    getScope(context: ReferenceInfo): Scope;\r\n\r\n}\r\n\r\nexport class DefaultScopeProvider implements ScopeProvider {\r\n\r\n    protected readonly reflection: AstReflection;\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly descriptions: AstNodeDescriptionProvider;\r\n    protected readonly indexManager: IndexManager;\r\n\r\n    protected readonly globalScopeCache: WorkspaceCache<string, Scope>;\r\n\r\n    constructor(services: LangiumCoreServices) {\r\n        this.reflection = services.shared.AstReflection;\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\r\n        this.indexManager = services.shared.workspace.IndexManager;\r\n        this.globalScopeCache = new WorkspaceCache<string, Scope>(services.shared);\r\n    }\r\n\r\n    getScope(context: ReferenceInfo): Scope {\r\n        const scopes: Array<Stream<AstNodeDescription>> = [];\r\n        const referenceType = this.reflection.getReferenceType(context);\r\n\r\n        const precomputed = getDocument(context.container).precomputedScopes;\r\n        if (precomputed) {\r\n            let currentNode: AstNode | undefined = context.container;\r\n            do {\r\n                const allDescriptions = precomputed.get(currentNode);\r\n                if (allDescriptions.length > 0) {\r\n                    scopes.push(stream(allDescriptions).filter(\r\n                        desc => this.reflection.isSubtype(desc.type, referenceType)));\r\n                }\r\n                currentNode = currentNode.$container;\r\n            } while (currentNode);\r\n        }\r\n\r\n        let result: Scope = this.getGlobalScope(referenceType, context);\r\n        for (let i = scopes.length - 1; i >= 0; i--) {\r\n            result = this.createScope(scopes[i], result);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a scope for the given collection of AST node descriptions.\r\n     */\r\n    protected createScope(elements: Iterable<AstNodeDescription>, outerScope?: Scope, options?: ScopeOptions): Scope {\r\n        return new StreamScope(stream(elements), outerScope, options);\r\n    }\r\n\r\n    /**\r\n     * Create a scope for the given collection of AST nodes, which need to be transformed into respective\r\n     * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.\r\n     */\r\n    protected createScopeForNodes(elements: Iterable<AstNode>, outerScope?: Scope, options?: ScopeOptions): Scope {\r\n        const s = stream(elements).map(e => {\r\n            const name = this.nameProvider.getName(e);\r\n            if (name) {\r\n                return this.descriptions.createDescription(e, name);\r\n            }\r\n            return undefined;\r\n        }).nonNullable();\r\n        return new StreamScope(s, outerScope, options);\r\n    }\r\n\r\n    /**\r\n     * Create a global scope filtered for the given reference type.\r\n     */\r\n    protected getGlobalScope(referenceType: string, _context: ReferenceInfo): Scope {\r\n        return this.globalScopeCache.get(referenceType, () => new MapScope(this.indexManager.allElements(referenceType)));\r\n    }\r\n\r\n}\r\n"],"mappings":"AAAA;;;;;AAaA,SAASA,QAAQ,EAAEC,WAAW,QAAQ,YAAY;AAClD,SAASC,WAAW,QAAQ,uBAAuB;AACnD,SAASC,MAAM,QAAQ,oBAAoB;AAC3C,SAASC,cAAc,QAAQ,qBAAqB;AAiBpD,OAAM,MAAOC,oBAAoB;EAS7BC,YAAYC,QAA6B;IACrC,IAAI,CAACC,UAAU,GAAGD,QAAQ,CAACE,MAAM,CAACC,aAAa;IAC/C,IAAI,CAACC,YAAY,GAAGJ,QAAQ,CAACK,UAAU,CAACC,YAAY;IACpD,IAAI,CAACC,YAAY,GAAGP,QAAQ,CAACQ,SAAS,CAACC,0BAA0B;IACjE,IAAI,CAACC,YAAY,GAAGV,QAAQ,CAACE,MAAM,CAACM,SAAS,CAACG,YAAY;IAC1D,IAAI,CAACC,gBAAgB,GAAG,IAAIf,cAAc,CAAgBG,QAAQ,CAACE,MAAM,CAAC;EAC9E;EAEAW,QAAQA,CAACC,OAAsB;IAC3B,MAAMC,MAAM,GAAsC,EAAE;IACpD,MAAMC,aAAa,GAAG,IAAI,CAACf,UAAU,CAACgB,gBAAgB,CAACH,OAAO,CAAC;IAE/D,MAAMI,WAAW,GAAGvB,WAAW,CAACmB,OAAO,CAACK,SAAS,CAAC,CAACC,iBAAiB;IACpE,IAAIF,WAAW,EAAE;MACb,IAAIG,WAAW,GAAwBP,OAAO,CAACK,SAAS;MACxD,GAAG;QACC,MAAMG,eAAe,GAAGJ,WAAW,CAACK,GAAG,CAACF,WAAW,CAAC;QACpD,IAAIC,eAAe,CAACE,MAAM,GAAG,CAAC,EAAE;UAC5BT,MAAM,CAACU,IAAI,CAAC7B,MAAM,CAAC0B,eAAe,CAAC,CAACI,MAAM,CACtCC,IAAI,IAAI,IAAI,CAAC1B,UAAU,CAAC2B,SAAS,CAACD,IAAI,CAACE,IAAI,EAAEb,aAAa,CAAC,CAAC,CAAC;QACrE;QACAK,WAAW,GAAGA,WAAW,CAACS,UAAU;MACxC,CAAC,QAAQT,WAAW;IACxB;IAEA,IAAIU,MAAM,GAAU,IAAI,CAACC,cAAc,CAAChB,aAAa,EAAEF,OAAO,CAAC;IAC/D,KAAK,IAAImB,CAAC,GAAGlB,MAAM,CAACS,MAAM,GAAG,CAAC,EAAES,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACzCF,MAAM,GAAG,IAAI,CAACG,WAAW,CAACnB,MAAM,CAACkB,CAAC,CAAC,EAAEF,MAAM,CAAC;IAChD;IACA,OAAOA,MAAM;EACjB;EAEA;;;EAGUG,WAAWA,CAACC,QAAsC,EAAEC,UAAkB,EAAEC,OAAsB;IACpG,OAAO,IAAI3C,WAAW,CAACE,MAAM,CAACuC,QAAQ,CAAC,EAAEC,UAAU,EAAEC,OAAO,CAAC;EACjE;EAEA;;;;EAIUC,mBAAmBA,CAACH,QAA2B,EAAEC,UAAkB,EAAEC,OAAsB;IACjG,MAAME,CAAC,GAAG3C,MAAM,CAACuC,QAAQ,CAAC,CAACK,GAAG,CAACC,CAAC,IAAG;MAC/B,MAAMC,IAAI,GAAG,IAAI,CAACtC,YAAY,CAACuC,OAAO,CAACF,CAAC,CAAC;MACzC,IAAIC,IAAI,EAAE;QACN,OAAO,IAAI,CAACnC,YAAY,CAACqC,iBAAiB,CAACH,CAAC,EAAEC,IAAI,CAAC;MACvD;MACA,OAAOG,SAAS;IACpB,CAAC,CAAC,CAACC,WAAW,EAAE;IAChB,OAAO,IAAIpD,WAAW,CAAC6C,CAAC,EAAEH,UAAU,EAAEC,OAAO,CAAC;EAClD;EAEA;;;EAGUL,cAAcA,CAAChB,aAAqB,EAAE+B,QAAuB;IACnE,OAAO,IAAI,CAACnC,gBAAgB,CAACW,GAAG,CAACP,aAAa,EAAE,MAAM,IAAIvB,QAAQ,CAAC,IAAI,CAACiB,YAAY,CAACsC,WAAW,CAAChC,aAAa,CAAC,CAAC,CAAC;EACrH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}